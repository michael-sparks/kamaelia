<html>
<head>
<title> index </title>
<link rel=stylesheet type="text/css" href="/site-resources/base.css">
<link rel=stylesheet type="text/css" href="/site-resources/pandoc.css">
</head>
<body>
<div class="banner">
<P> <a href="/Home.html">Home</a> | <a href="/About.html">About</a> | <a href="/Developers.html">Developers</a>
</div>
<div class="pagecontainer">
<div class="pagesection">
<div id="pagenote">
<p>Feb 2024 - This site, and Kamaelia are <a href="https://github.com/sparkslabs/kamaelia/issues/15">being updated</a>. There is significant work needed, and <a href="https://github.com/sparkslabs/kamaelia/pulls">PRs</a> are welcome.
</div>
<div class="container">
<h1 id="kamaelia.ui.opengl.opengldisplay"><a href="/Components/pydoc/Kamaelia.html" class="reference">Kamaelia</a>.<a href="/Components/pydoc/Kamaelia.UI.html" class="reference">UI</a>.<a href="/Components/pydoc/Kamaelia.UI.OpenGL.html" class="reference">OpenGL</a>.<a href="/Components/pydoc/Kamaelia.UI.OpenGL.OpenGLDisplay.html" class="reference">OpenGLDisplay</a></h1>
<section>
<div class="container">
<ul>
<li><strong>component <a href="/Components/pydoc/Kamaelia.UI.OpenGL.OpenGLDisplay.OpenGLDisplay.html" class="reference">OpenGLDisplay</a></strong></li>
</ul>
</div>
<ul>
<li><a href="#309" class="reference">OpenGL Display Service</a>
<ul>
<li><a href="#310" class="reference">Example Usage</a></li>
<li><a href="#311" class="reference">How does it work?</a>
<ul>
<li><a href="#312" class="reference">OpenGL components</a></li>
<li><a href="#313" class="reference">Pygame components</a></li>
<li><a href="#314" class="reference">Pygame wrappers</a></li>
<li><a href="#315" class="reference">Listening to events</a></li>
<li><a href="#316" class="reference">Eventspies</a></li>
<li><a href="#317" class="reference">Shutdown</a></li>
</ul></li>
</ul></li>
</ul>
</section>
<h1 id="opengl-display-service-309">OpenGL Display Service {#309}</h1>
<p>This component provides an OpenGL window and manages input events, positioning and drawing of other components. It handles both OpenGL and Pygame components.</p>
<p>OpenGLDisplay is a service that registers with the Coordinating Assistant Tracker (CAT).</p>
<h2 id="example-usage-310"><span id="example-usage">Example Usage</span> {#310}</h2>
<p>If you want to change some of the default parameters, like the viewport, you first have to create an OpenGLDisplay object and then register it. The following would show a simple cube from a slightly changed viewer position:</p>
<pre class="literal-block"><code>display = OpenGLDisplay(viewerposition=(0,-10,0), lookat=(0,0,-15)).activate()
OpenGLDisplay.setDisplayService(display)

SimpleCube(position=(0,0,-15)).activate()</code></pre>
<p>If you want to use pygame components, you have to override the PygameDisplay service before creating any pygame components:</p>
<pre class="literal-block"><code>display = OpenGLDisplay.getDisplayService()
PygameDisplay.setDisplayService(display[0])</code></pre>
<p>For examples of how components have to interfrere with OpenGLDisplay, please have a look at OpenGLComponent.py and Interactor.py.</p>
<h2 id="how-does-it-work-311"><span id="how-does-it-work">How does it work?</span> {#311}</h2>
<p>OpenGLDisplay is a service. obtain it by calling the OpenGLDisplay.getDisplayService(...) static method. Any existing instance will be returned, otherwise a new one is automatically created.</p>
<p>Alternatively, if you wish to configure OpenGLDisplay with options other than the defaults, create your own instance, then register it as a service by calling the PygameDisplay.setDisplayService(...) static method. NOTE that it is only advisable to do this at the top level of your system, as other components may have already requested and created a OpenGLDisplay component!</p>
<p>When using only OpenGL components and no special display settings have to be made, you won't see OpenGLDisplay as it is registered automatically when it is first requested (by invoking the getDisplayService(...) static method).</p>
<p>You can also use an instance of OpenGLDisplay to override the PygameDisplay service as it implements most of the functionality of PygameDisplay. You will want to do this when you want to use Pygame components along with OpenGL components.</p>
<p>pygame only supports one display window at a time, you must not make more than one OpenGLDisplay component.</p>
<p>OpenGLDisplay listens for requests arriving at its "notify" inbox. A request can currently be to:</p>
<ul>
<li>register an OpenGL component (OGL_DISPLAYREQUEST)</li>
<li>register a pygame component (DISPLAYREQUEST)</li>
<li>register a pygame wrapper (WRAPPERREQUEST)</li>
<li>register an eventspy (EVENTSPYREQUEST)</li>
<li>listen or stop listening to events (ADDLISTENEVENT, REMOVELISTENEVENT)</li>
<li>update the displaylist of an OpenGL component (UPDATE_DISPLAYLIST)</li>
<li>update the transform of an OpenGL component (UPDATE_TRANSFORM)</li>
<li>invoke a redraw of a pygame surface (REDRAW)</li>
</ul>
<h3 id="opengl-components-312"><span id="opengl-components">OpenGL components</span> {#312}</h3>
<p>OpenGL components get registered by an OGL_DISPLAYREQUEST. Such a request is a dictionary with the following keys:</p>
<pre class="literal-block"><code>{
    &quot;OGL_DISPLAYREQUEST&quot;: True,     # OpenGL Display request
    &quot;objectid&quot; : id(object),            # id of requesting object (for identification)
    &quot;callback&quot; : (component,&quot;inboxname&quot;),   # to send the generated event id to

    &quot;events&quot; : (component, &quot;inboxname&quot;),    # to send event notification (optional)
    &quot;size&quot;: (x,y,z),                # size of object (not yet used)
}</code></pre>
<p>When OpenGLDisplay received such a request it generates an identifier and returns it to the box you specify by "callback". This identifier can later be used to determine if a mouse event "hit" the object.</p>
<p>It is important to note that OpenGL don't draw and transform themselves directly but only hand displaylists and Transform objects to the display service. After an OpenGL component has been registered, it can send displaylist- and transform-updates. These requests are dictionaries of the following form:</p>
<pre class="literal-block"><code>{
    &quot;DISPLAYLIST_UPDATE&quot;: True, # update displaylist
    &quot;objectid&quot;: id(object),     # id of requesting object
    &quot;displaylist&quot;: displaylist  # new displaylist
}</code></pre>
<p>If an object is static, i.e. does not change its geometry, it only needs to send this update one time. Dynamic objects can provide new displaylists as often as they need to.:</p>
<pre class="literal-block"><code>{
    &quot;TRANSFORM_UPDATE&quot;: True,   # update transform
    &quot;objectid&quot;: id(self),       # id of requesting object
    &quot;transform&quot;: self.transform # new transform
}</code></pre>
<p>A transform update should be sent every time the object transform changes, i.e. it is moved.</p>
<p>OpenGL components can also request listening to events. See "Listening to events" below.</p>
<p>It is generally recommended to use the class OpenGLComponent as base class for OpenGL components. It implements all the functionality required to create, draw, move OpenGL components and to handle events (see OpenGLComponent.py for the class and e.g. SimpleCube.py, Button.py and other components for examples).</p>
<h3 id="pygame-components-313"><span id="pygame-components">Pygame components</span> {#313}</h3>
<p>OpenGLDisplay is designed to be compatible with PygameDisplay. After overriding the PygameDisplay service, pygame components can be created as usual. See the documentation of PygameDisplay (Kamaelia/UI/PygameDisplay.py) for how to do this.</p>
<p>NOTE: Overlays are not supported yet.</p>
<h3 id="pygame-wrappers-314"><span id="pygame-wrappers">Pygame wrappers</span> {#314}</h3>
<p>It is possibly, by sending a WRAPPERREQUEST, to wrap an already registered pygame component by a OpenGL component. The surface of the pygame component is then excluded from normal drawing and this responsibility is handed to the requesting component by giving it the texture name corresponding to the surface. The event processing of mouse events is then also relinked to be done by the wrapper.</p>
<p>The wrapper request is a dictionary with the following keys:</p>
<pre class="literal-block"><code>{
    &quot;WRAPPERREQUEST&quot; : True,                    # wrap a pygame component
    &quot;wrapcallback&quot; : (object, &quot;inboxname&quot;),     # send response here
    &quot;eventrequests&quot; : (object, &quot;inboxname&quot;),    # to receive event requests by the wrapped component
    &quot;wrap_objectid&quot;: id(wrapped_component)      # object id of the component to be wrapped
}</code></pre>
<p>When a WRAPPERREQUEST is received for a component which is not registered yet, it is stored until the component to be wrapped gets registered.</p>
<p>When a wrapper request was received, the OpenGL display service returns a dictionary to the box specified by "wrapcallback" containing the following keys:</p>
<pre class="literal-block"><code>{
    &quot;texname&quot;: texname,             # OpenGL texture name
    &quot;texsize&quot;: (width, height),     # texture coordinate size
    &quot;size&quot;: (width, height)         # size of pygame surface in pixels
}</code></pre>
<p>See PygameWrapperPlane.py for an example implementation of a wrapper.</p>
<h3 id="listening-to-events-315"><span id="listening-to-events">Listening to events</span> {#315}</h3>
<p>Once your component has been registered, it can request to be notified of specific pygame events. The same requests are used for Pygame and OpenGL components, only the keys are slightly different.</p>
<p>To request to listen to a given event, send a dictionary to the "notify" inbox, containing the following:</p>
<pre class="literal-block"><code>{
    &quot;ADDLISTENEVENT&quot; : pygame_eventtype,    # example: pygame.KEYDOWN
    &quot;surface&quot; : your_surface,               # for pygame components
    &quot;objectid&quot; : id(object),                # for OpenGL components
}</code></pre>
<p>To unsubscribe from a given event, send a dictionary containing:</p>
<pre class="literal-block"><code>{
    &quot;REMOVELISTENEVENT&quot; : pygame_eventtype,
    &quot;surface&quot; : your_surface,               # for pygame components
    &quot;objectid&quot; : id(object),                # for OpenGL components
}</code></pre>
<p>Events will be sent to the inbox specified in the "events" key of the "DISPLAYREQUEST" or "OGL_DISPLAYREQUEST" message. They arrive as a list of pygame event objects.</p>
<p>The events objects of type Bunch with the following variables:</p>
<ul>
<li>type -- Pygame event type</li>
</ul>
<blockquote>
<p>For events of type pygame.KEYDOWN, pygame.KEYUP:</p>
</blockquote>
<ul>
<li>key -- Pressed or released key</li>
</ul>
<blockquote>
<p>For events of type pygame.MOUSEBUTTONDOWN, pygame.MOUSEBUTTONUP:</p>
</blockquote>
<ul>
<li>pos -- Mouse position</li>
<li>button -- Pressed or released mouse button number</li>
</ul>
<blockquote>
<p>For events of type pygame.MOUSEMOTION:</p>
</blockquote>
<ul>
<li>rel -- Relative mouse motion.</li>
<li>buttons -- Buttons pressed while mousemotion</li>
</ul>
<blockquote>
<p>For events of type pygame.MOUSEBUTTONDOWN, pygame.MOUSEBUTTONUP, pygame.MOUSEMOTION when sent to OpenGL components:</p>
</blockquote>
<ul>
<li>viewerposition -- Position of viewer</li>
<li>dir -- Direction vector of generated from mouse position</li>
<li>hitobjects -- List of hit objects</li>
</ul>
<p>NOTE: If the event is MOUSEMOTION, MOUSEBUTTONUP or MOUSEBUTTONDOWN then you will instead receive a replacement object, with the same attributes as the pygame event. But for pygame components, the 'pos' attribute adjusted so that (0,0) is the top left corner of <em>your</em> surface. For OpenGL components the origin and direction of the intersection vector determined using the mouse position and viewport will be added as well as a list of identfiers of objects that has been hit.</p>
<p>If a component has requested reception of an event type, it gets every event that happens of that type, regardless if it is of any concern to the component. In the case of mouse events there is a list of hit objects included which are determined by using OpenGL picking.</p>
<h3 id="eventspies-316"><span id="eventspies">Eventspies</span> {#316}</h3>
<p>Eventspies are components that basically listen to events for other components. They are registered by sending an EVENSPYREQUEST:</p>
<pre class="literal-block"><code>{
    &quot;EVENTSPYREQUEST&quot; : True,
    &quot;objectid&quot; : id(object),            # id of requesting object
    &quot;target&quot;: id(target),               # id of object to be spied
    &quot;callback&quot; : (object,&quot;inboxname&quot;),  # for sending event identifier
    &quot;events&quot; : (object, &quot;inboxname&quot;)    # for reception of events
}</code></pre>
<p>In return you get the identifier of the target component that can be used to determine if the target component has been hit. An evenspy can request reception of event types like usual (using ADDLISTENEVENT and REMOVELISTENEVENT). When events are spied this does not affect normal event processing.</p>
<h3 id="shutdown-317"><span id="shutdown">Shutdown</span> {#317}</h3>
<p>Upon reception of a pygame.QUIT event, OpenGLDisplay sends an <a href="/Docs/Axon/Axon.Ipc.shutdownMicroprocess.html" class="reference">Axon.Ipc.shutdownMicroprocess</a> object out of its signal outbox. The service itself does not terminate.</p>
<hr />
<h1 id="kamaelia.ui.opengl.opengldisplay.opengldisplay"><a href="/Components/pydoc/Kamaelia.html" class="reference">Kamaelia</a>.<a href="/Components/pydoc/Kamaelia.UI.html" class="reference">UI</a>.<a href="/Components/pydoc/Kamaelia.UI.OpenGL.html" class="reference">OpenGL</a>.<a href="/Components/pydoc/Kamaelia.UI.OpenGL.OpenGLDisplay.html" class="reference">OpenGLDisplay</a>.<a href="/Components/pydoc/Kamaelia.UI.OpenGL.OpenGLDisplay.OpenGLDisplay.html" class="reference">OpenGLDisplay</a></h1>
<h2 id="symbol-OpenGLDisplay">class OpenGLDisplay(<a href="/Docs/Axon/Axon.AdaptiveCommsComponent.AdaptiveCommsComponent.html" class="reference">Axon.AdaptiveCommsComponent.AdaptiveCommsComponent</a>)</h2>
<p>OpenGLDisplay(...) -&gt; new OpenGLDisplay component</p>
<p>Use OpenGLDisplay.getDisplayService(...) in preference as it returns an existing instance, or automatically creates a new one.</p>
<p>Or create your own and register it with setDisplayService(...)</p>
<p>Keyword arguments (all optional):</p>
<ul>
<li><p>title -- caption of window (default=http://kamaelia.sourceforge.net)</p></li>
<li><p>width -- pixels width (default=800)</p></li>
<li><p>height -- pixels height (default=600)</p></li>
<li><p>background_colour -- (r,g,b) background colour (default=(255,255,255))</p></li>
<li><p>fullscreen -- set to True to start up fullscreen, not windowed (default=False)</p></li>
<li><p>show_fps -- show frames per second in window title (default=True)</p></li>
<li><dl>
<dt>limit_fps -- maximum frame rate (default=60)</dt>
<dd><p>Projection parameters</p>
</dd>
</dl></li>
<li><p>near -- distance to near plane (default=1.0)</p></li>
<li><p>far -- distance to far plane (default=100.0)</p></li>
<li><dl>
<dt>perspective -- perspective angle (default=45.0)</dt>
<dd><p>Viewer position and orientation</p>
</dd>
</dl></li>
<li><p>viewerposition -- position of viewer (default=(0,0,0))</p></li>
<li><p>lookat -- look at point (default= (0,0,-self.farPlaneDist))</p></li>
<li><dl>
<dt>up -- up vector (default(0,1,0))</dt>
<dd><p>Fog</p>
</dd>
</dl></li>
<li><p>fog -- tuple of fog distances (start, end). if not set, fog is disabled (default)</p></li>
<li><p>fog_colour -- (r,g,b) fog colour (default=(255,255,255) )</p></li>
<li><dl>
<dt>fog_density -- fog density (default=0.35)</dt>
<dd><p>Event processing</p>
</dd>
</dl></li>
<li><p>hitall -- boolean, if false, only the nearest object under the cursor gets activated (default=False)</p></li>
</ul>
<h3 id="inboxes"><span id="symbol-OpenGLDisplay.Inboxes">Inboxes</span></h3>
<ul>
<li><strong>control</strong> : NOT USED</li>
<li><strong>events</strong> : For reception of pygame events</li>
<li><strong>inbox</strong> : Default inbox, not currently used</li>
<li><strong>notify</strong> : For reception of requests for surfaces, overlays and events</li>
</ul>
<h3 id="outboxes"><span id="symbol-OpenGLDisplay.Outboxes">Outboxes</span></h3>
<ul>
<li><strong>outbox</strong> : NOT USED</li>
<li><strong>signal</strong> : NOT USED</li>
</ul>
<h3 id="methods-defined-here">Methods defined here</h3>
<div class="container">
<div class="boxright">
<p><strong>Warning!</strong></p>
<p>You should be using the inbox/outbox interface, not these methods (except construction). This documentation is designed as a roadmap as to their functionalilty for maintainers and new component developers.</p>
</div>
</div>
<h4 id="init__self-argd"><span id="symbol-OpenGLDisplay.__init__">__init__(self, **argd)</span></h4>
<p>x.__init__(...) initializes x; see x.__class__.__doc__ for signature</p>
<h4 id="calcpow2sizeself-size"><span id="symbol-OpenGLDisplay.calcPow2Size">calcPow2Size(self, size)</span></h4>
<p>Calculates the power of 2 dimensions for a given size.</p>
<h4 id="dopickingself-pos"><span id="symbol-OpenGLDisplay.doPicking">doPicking(self, pos)</span></h4>
<p>Uses OpenGL picking to determine objects that have been hit by mouse pointer. see e.g. OpenGL Redbook</p>
<h4 id="drawopenglcomponentsself"><span id="symbol-OpenGLDisplay.drawOpenGLComponents">drawOpenGLComponents(self)</span></h4>
<p>Draws all registered OpenGL components with their set transformation matrix.</p>
<h4 id="drawpygamesurfacesself"><span id="symbol-OpenGLDisplay.drawPygameSurfaces">drawPygameSurfaces(self)</span></h4>
<p>Draws all surfaces of registered pygame components on top of everything else.</p>
<h4 id="genidentifierself"><span id="symbol-OpenGLDisplay.genIdentifier">genIdentifier(self)</span></h4>
<p>Returns a unique number.</p>
<h4 id="handleeventsself"><span id="symbol-OpenGLDisplay.handleEvents">handleEvents(self)</span></h4>
<p>Handles pygame input events.</p>
<h4 id="handleoglcomponenteventsself-events"><span id="symbol-OpenGLDisplay.handleOGLComponentEvents">handleOGLComponentEvents(self, events)</span></h4>
<p>Prepare and send input events for OpenGL components.</p>
<h4 id="handlepygamecomponenteventsself-events"><span id="symbol-OpenGLDisplay.handlePygameComponentEvents">handlePygameComponentEvents(self, events)</span></h4>
<p>Prepare and send input events for pygame components.</p>
<h4 id="handlerequest_displayrequestself-message"><span id="symbol-OpenGLDisplay.handleRequest_DISPLAYREQUEST">handleRequest_DISPLAYREQUEST(self, message)</span></h4>
<h4 id="handlerequest_eventspyrequestself-message"><span id="symbol-OpenGLDisplay.handleRequest_EVENTSPYREQUEST">handleRequest_EVENTSPYREQUEST(self, message)</span></h4>
<h4 id="handlerequest_ogl_displayrequestself-message"><span id="symbol-OpenGLDisplay.handleRequest_OGL_DISPLAYREQUEST">handleRequest_OGL_DISPLAYREQUEST(self, message)</span></h4>
<h4 id="handlerequest_wrapperrequestself-message"><span id="symbol-OpenGLDisplay.handleRequest_WRAPPERREQUEST">handleRequest_WRAPPERREQUEST(self, message)</span></h4>
<h4 id="handlerequestsself"><span id="symbol-OpenGLDisplay.handleRequests">handleRequests(self)</span></h4>
<p>Handles service requests.</p>
<h4 id="mainself"><span id="symbol-OpenGLDisplay.main">main(self)</span></h4>
<p>Main loop.</p>
<h4 id="setprojectionself"><span id="symbol-OpenGLDisplay.setProjection">setProjection(self)</span></h4>
<p>Sets projection matrix.</p>
<h4 id="surfacepositionself-surface"><span id="symbol-OpenGLDisplay.surfacePosition">surfacePosition(self, surface)</span></h4>
<p>Returns a suggested position for a surface. No guarantees its any good!</p>
<h4 id="updatedisplayself"><span id="symbol-OpenGLDisplay.updateDisplay">updateDisplay(self)</span></h4>
<p>Draws all components, updates screen, clears the backbuffer and depthbuffer .</p>
<h4 id="updatepygametextureself-surface-pow2surface-texname"><span id="symbol-OpenGLDisplay.updatePygameTexture">updatePygameTexture(self, surface, pow2surface, texname)</span></h4>
<p>Converts the surface of a pygame component to an OpenGL texture.</p>
<section>

</section>
</div>
<h1 id="feedback">Feedback</h1>
<p>Got a problem with the documentation? Something unclear that could be clearer? Want to help improve it? Constructive criticism is very welcome - especially if you can suggest a better rewording!</p>
<p>Please leave you feedback <a href="../../../cgi-bin/blog/blog.cgi?rm=viewpost&amp;nodeid=1142023701" class="reference">here</a> in reply to the documentation thread in the Kamaelia blog.</p>
<p><em>-- Automatic documentation generator, 05 Jun 2009 at 03:01:38 UTC/GMT</em></p>

</div> <!-- end section -->
</div> <!-- end page container -->

<div class="banner">
<a href="https://www.bbc.co.uk/rd"><img src="/site-resources/BBCRD_Logo.jpg"></a>
<P id="mini">  Kamaelia is an open source project originated from and guided
by <a href="https://www.bbc.co.uk/rd">BBC Research.</a> For more information
browse the site or get in contact.
<br>This is an ongoing community based development site.  As a result the
contents of this page is the opinions of the contributors of the pages
involved not the organisations involved.  Specificially, this page may
contain personal views which are not the views of the BBC.

<br>(C) Copyright 2004-2024 Kamaelia Contributors, including the British
Broadcasting Corporation, All Rights Reserved.
</div>
</body>
</html>
