<html>
<head>
<title> index </title>
<link rel=stylesheet type="text/css" href="/site-resources/base.css">
<link rel=stylesheet type="text/css" href="/site-resources/pandoc.css">
</head>
<body>
<div class="banner">
<P> <a href="/Home.html">Home</a> | 
    <a href="/About.html">About</a> | 
    <a href="/RecentChanges.html">Recent Changes</a> | 
    <a href="/Documentation.html">Documentation</a> |
    <a href="/Community.html">Community</a>
</div>
<div class="pagecontainer">
<div class="pagesection">
<div id="pagenote">
<p>Feb 2024 - This site, and Kamaelia are <a href="https://github.com/sparkslabs/kamaelia/issues/15">being updated</a>. There is significant work needed, and <a href="https://github.com/sparkslabs/kamaelia/pulls">PRs</a> are welcome.
</div>
<div class="container">
<h1 id="kamaelia.util.ratefilter"><a href="/Components/pydoc/Kamaelia.html" class="reference">Kamaelia</a>.<a href="/Components/pydoc/Kamaelia.Util.html" class="reference">Util</a>.<a href="/Components/pydoc/Kamaelia.Util.RateFilter.html" class="reference">RateFilter</a></h1>
<section>
<div class="container">
<ul>
<li><strong>component <a href="/Components/pydoc/Kamaelia.Util.RateFilter.ByteRate_RequestControl.html" class="reference">ByteRate_RequestControl</a></strong></li>
<li><strong>component <a href="/Components/pydoc/Kamaelia.Util.RateFilter.MessageRateLimit.html" class="reference">MessageRateLimit</a></strong></li>
<li><strong>component <a href="/Components/pydoc/Kamaelia.Util.RateFilter.OnDemandLimit.html" class="reference">OnDemandLimit</a></strong></li>
<li><strong>component <a href="/Components/pydoc/Kamaelia.Util.RateFilter.VariableByteRate_RequestControl.html" class="reference">VariableByteRate_RequestControl</a></strong></li>
</ul>
</div>
<ul>
<li><a href="#168" class="reference">Message Rate limiting</a>
<ul>
<li><a href="#169" class="reference">Example Usage</a></li>
<li><a href="#170" class="reference">How does it work?</a></li>
</ul></li>
<li><a href="#171" class="reference">Rate Control</a>
<ul>
<li><a href="#172" class="reference">Example Usage</a></li>
<li><a href="#173" class="reference">How does it work?</a></li>
</ul></li>
<li><a href="#174" class="reference">Flow limiting by request</a>
<ul>
<li><a href="#175" class="reference">Example Usage</a></li>
<li><a href="#176" class="reference">How does it work?</a></li>
</ul></li>
</ul>
</section>
<section>
<p>These components limit the rate of data flow, either by buffering or by taking charge and requesting data at a given rate.</p>
<h2 id="message-rate-limiting-168"><span id="message-rate-limiting">Message Rate limiting</span> {#168}</h2>
<p>This component buffers incoming messages and limits the rate at which they are sent on.</p>
<h3 id="example-usage-169"><span id="example-usage">Example Usage</span> {#169}</h3>
<p>Regulating video to a constant framerate, buffering 2 seconds of data before starting to emit frames:</p>
<pre class="literal-block"><code>Pipeline( RateControlledFileReader(...),
          DiracDecoder(),
          MessageRateLimit(messages_per_second=framerate, buffer=2*framerate),
          VideoOverlay(),
        ).activate()</code></pre>
<h3 id="how-does-it-work-170"><span id="how-does-it-work">How does it work?</span> {#170}</h3>
<p>Data items sent to this component's "inbox" inbox are buffered. Once the buffer is full, the component starts to emit items at the specified rate to its "outbox" outbox.</p>
<p>If there is a shortage of data in the buffer, then the specified rate of output will, obviously, not be sustained. Items will be output when they are available.</p>
<p>The specified rate serves as a ceiling limit - items will never be emitted faster than that rate, though they may be emitted slower.</p>
<p>Make sure you choose a sufficient buffer size to handle any expected jitter/temporary shortages of data.</p>
<p>If a producerFinished or shutdownMicroprocess message is received on the components' "control" inbox, it is sent on out of the "signal" outbox. The component will then immediately terminate.</p>
<h2 id="rate-control-171"><span id="rate-control">Rate Control</span> {#171}</h2>
<p>These components control the rate of a system by requesting data at a given rate. The 'variable' version allows this rate to the changed whilst running.</p>
<h3 id="example-usage-172"><span id="id1">Example Usage</span> {#172}</h3>
<p>Reading from a file at a fixed rate:</p>
<pre class="literal-block"><code>Graphline( ctrl   = ByteRate_RequestControl(rate=1000, chunksize=32),
           reader = PromptedFileReader(filename=&quot;myfile&quot;, readmode=&quot;bytes&quot;),
           linkages = {
                (&quot;ctrl&quot;, &quot;outbox&quot;) : (&quot;reader&quot;,&quot;inbox&quot;),
                (&quot;reader&quot;, &quot;outbox&quot;) : (&quot;self&quot;, &quot;outbox&quot;),

                (&quot;self&quot;, &quot;control&quot;) : (&quot;reader&quot;, &quot;control&quot;),
                (&quot;reader&quot;, &quot;signal&quot;) : (&quot;ctrl&quot;, &quot;control&quot;),
                (&quot;ctrl, &quot;signal&quot;) : (&quot;self&quot;, &quot;signal&quot;),
              }</code></pre>
<p>Note that the "signal"-"control" path goes in the opposite direction so that when the file is finished reading, the ByteRate_RequestControl component receives a shutdown message.</p>
<p>Reading from a file at a varying rate (send new rates to the "inbox" inbox):</p>
<pre class="literal-block"><code>Graphline( ctrl   = VariableByteRate_RequestControl(rate=1000, chunksize=32),
           reader = PromptedFileReader(filename=&quot;myfile&quot;, readmode=&quot;bytes&quot;),
           linkages = {
                  (&quot;self&quot;, &quot;inbox&quot;) : (&quot;ctrl&quot;, &quot;inbox&quot;),
                  (&quot;ctrl&quot;, &quot;outbox&quot;) : (&quot;reader&quot;,&quot;inbox&quot;),
                  (&quot;reader&quot;, &quot;outbox&quot;) : (&quot;self&quot;, &quot;outbox&quot;),

                  (&quot;self&quot;, &quot;control&quot;) : (&quot;reader&quot;, &quot;control&quot;),
                  (&quot;reader&quot;, &quot;signal&quot;) : (&quot;ctrl&quot;, &quot;control&quot;),
                  (&quot;ctrl, &quot;signal&quot;) : (&quot;self&quot;, &quot;signal&quot;),
              }
         ).activate()</code></pre>
<p>Note that the "signal"-"control" path goes in the opposite direction so that when the file is finished reading, the VariableByteRate_RequestControl component receives a shutdown message.</p>
<h3 id="how-does-it-work-173"><span id="id2">How does it work?</span> {#173}</h3>
<p>These components emit from their "outbox" outboxes, requests for data at the specified rate. Each request is an integer specifying the number of items.</p>
<p>Rates are in no particular units (eg. bitrate, framerate) - you can use it for whatever purpose you wish. Just ensure your values fit the units you are working in.</p>
<p>At initialisation, you specify not only the rate, but also the chunk size or chunk rate. For example, a rate of 12 and chunksize of 4 will result in 3 requests per second, each for 4 items. Conversely, specifying a rate of 12 and a chunkrate of 2 will result in 2 requests per second, each for 6 items.</p>
<p>The rate and chunk size or chunk rate you specify does not have to be integer or divide into integers. For example, you can specify a rate of 10 and a chunksize of 3. Requests will then be emitted every 0.3 seconds, each for 3 items.</p>
<p>When requests are emitted, they will always be for an integer number of items. Rounding errors are averaged out over time, and should not accumulate. Rounding will occur if chunksize, either specified, or calculated from chunkrate, is non-integer.</p>
<p>At initialisation, you can also specify that chunk 'aggregation' is permitted. If permitted, then the component can choose to exceed the specified chunksize. For example if, for some reason, the component gets behind, it might aggregate two requests together - the next request will be for twice as many items.</p>
<p>Another example would be if you, for example, specify a rate of 100 and chunkrate of 3. The 3 requests emitted every second will then be for 33, 33 and 34 items.</p>
<p>The VariableByteRate_RequestControl component allows the rate to be changed on-the-fly. Send a new rate to the component's "inbox" inbox and it will be adopted immediately. You cannot change the chunkrate or chunksize.</p>
<p>The new rate is adopted at the instant it is received. There will be no glitches in the apparent rate of requests due to your changing the rate.</p>
<p>If a producerFinished or shutdownMicroprocess message is received on the components' "control" inbox, it is sent on out of the "signal" outbox. The component will then immediately terminate.</p>
<h2 id="flow-limiting-by-request-174"><span id="flow-limiting-by-request">Flow limiting by request</span> {#174}</h2>
<p>This component buffers incoming data and emits it one item at a time, whenever a "NEXT" request is received.</p>
<h3 id="example-usage-175"><span id="id3">Example Usage</span> {#175}</h3>
<p>An app that reads data items from a file, then does something with then one at a time when the user clicks a visual button in pygame:</p>
<pre class="literal-block"><code>Graphline( source   = RateControlledFileReader(..., readmode=&quot;lines&quot;),
           limiter  = OnDemandLimit(),
           trigger  = Button(caption=&quot;Click for next&quot;,msg=&quot;NEXT&quot;),
           dest     = consumer(...),
           linkages = {
                   (&quot;source&quot;, &quot;outbox&quot;) : (&quot;limiter&quot;, &quot;inbox&quot;),
                   (&quot;limiter&quot;, &quot;outbox&quot;) : (&quot;dest&quot;, &quot;inbox&quot;),
                   (&quot;trigger&quot;, &quot;outbox&quot;) : (&quot;limiter&quot;, &quot;slidecontrol&quot;)
               }
         ).activate()</code></pre>
<h3 id="how-does-it-work-176"><span id="id4">How does it work?</span> {#176}</h3>
<p>Data items sent to the component's "inbox" inbox are buffered in a queue. Whenever a "NEXT" message is received on the component's "slidecontrol" inbox, an item is taken out of the queue and sent out of the "outbox" outbox.</p>
<p>Items come out in the same order they go in.</p>
<p>If a "NEXT" message is received but there are no items waiting in the queue, the "NEXT" message is discarded and nothing is emitted.</p>
<p>If a producerFinished message is received on the components' "control" inbox, it is sent on out of the "signal" outbox. The component will then immediately terminate.</p>
</section>
<hr />
<section>
<h1 id="kamaelia.util.ratefilter.byterate_requestcontrol"><a href="/Components/pydoc/Kamaelia.html" class="reference">Kamaelia</a>.<a href="/Components/pydoc/Kamaelia.Util.html" class="reference">Util</a>.<a href="/Components/pydoc/Kamaelia.Util.RateFilter.html" class="reference">RateFilter</a>.<a href="/Components/pydoc/Kamaelia.Util.RateFilter.ByteRate_RequestControl.html" class="reference">ByteRate_RequestControl</a></h1>
<h2 id="symbol-ByteRate_RequestControl">class ByteRate_RequestControl(<a href="/Docs/Axon/Axon.Component.component.html" class="reference">Axon.Component.component</a>)</h2>
<p>ByteRate_RequestControl([rate][,chunksize][,chunkrate][,allowchunkaggregation]) -&gt; new ByteRate_RequestControl component.</p>
<p>Controls rate of a data source by, at a controlled rate, emitting integers saying how much data to emit.</p>
<p>Keyword arguments:</p>
<ul>
<li>rate -- qty of data items per second (default=100000)</li>
<li>chunksize -- None or qty of items per 'chunk' (default=None)</li>
<li>chunkrate -- None or number of chunks per second (default=10)</li>
<li>allowchunkaggregation -- if True, chunksize will be enlarged if 'catching up' is necessary (default=False)</li>
</ul>
<p>Specify either chunksize or chunkrate, but not both.</p>
<h3 id="inboxes"><span id="symbol-ByteRate_RequestControl.Inboxes">Inboxes</span></h3>
<ul>
<li><strong>control</strong> : Shutdown signalling</li>
<li><strong>inbox</strong> : NOT USED</li>
</ul>
<h3 id="outboxes"><span id="symbol-ByteRate_RequestControl.Outboxes">Outboxes</span></h3>
<ul>
<li><strong>outbox</strong> : requests for 'n' items</li>
<li><strong>signal</strong> : Shutdown signalling</li>
</ul>
<h3 id="methods-defined-here">Methods defined here</h3>
<div class="container">
<div class="boxright">
<p><strong>Warning!</strong></p>
<p>You should be using the inbox/outbox interface, not these methods (except construction). This documentation is designed as a roadmap as to their functionalilty for maintainers and new component developers.</p>
</div>
</div>
<h4 id="init__self-rate-chunksize-chunkrate-allowchunkaggregation"><span id="symbol-ByteRate_RequestControl.__init__">__init__(self[, rate][, chunksize][, chunkrate][, allowchunkaggregation])</span></h4>
<p>x.__init__(...) initializes x; see x.__class__.__doc__ for signature</p>
<h4 id="getchunkstosendself"><span id="symbol-ByteRate_RequestControl.getChunksToSend">getChunksToSend(self)</span></h4>
<p>Generator. Returns the size of chunks to be requested (if any) to 'catch up' since last time this method was called.</p>
<h4 id="mainself"><span id="symbol-ByteRate_RequestControl.main">main(self)</span></h4>
<p>Main loop.</p>
<h4 id="resettimingself"><span id="symbol-ByteRate_RequestControl.resetTiming">resetTiming(self)</span></h4>
<p>Resets the timing variable used to determine when the next time to send a request is.</p>
<h4 id="shutdownself"><span id="symbol-ByteRate_RequestControl.shutdown">shutdown(self)</span></h4>
<p>Returns True if shutdown message received.</p>
<section>

</section>
<h1 id="kamaelia.util.ratefilter.messageratelimit"><a href="/Components/pydoc/Kamaelia.html" class="reference">Kamaelia</a>.<a href="/Components/pydoc/Kamaelia.Util.html" class="reference">Util</a>.<a href="/Components/pydoc/Kamaelia.Util.RateFilter.html" class="reference">RateFilter</a>.<a href="/Components/pydoc/Kamaelia.Util.RateFilter.MessageRateLimit.html" class="reference">MessageRateLimit</a></h1>
<h2 id="symbol-MessageRateLimit">class MessageRateLimit(<a href="/Docs/Axon/Axon.Component.component.html" class="reference">Axon.Component.component</a>)</h2>
<p>MessageRateLimit(messages_per_second[, buffer]) -&gt; new MessageRateLimit component.</p>
<p>Buffers messages and outputs them at a rate limited by the specified rate once the buffer is full.</p>
<p>Keyword arguments:</p>
<ul>
<li>messages_per_second -- maximum output rate</li>
<li>buffer -- size of buffer (0 or greater) (default=60)</li>
</ul>
<h3 id="inboxes-1"><span id="symbol-MessageRateLimit.Inboxes">Inboxes</span></h3>
<ul>
<li><strong>control</strong> : NOT USED</li>
<li><strong>inbox</strong> : Incoming items/messages</li>
</ul>
<h3 id="outboxes-1"><span id="symbol-MessageRateLimit.Outboxes">Outboxes</span></h3>
<ul>
<li><strong>outbox</strong> : Items/messages limited to specified maximum output rate</li>
<li><strong>signal</strong> : NOT USED</li>
</ul>
<h3 id="methods-defined-here-1">Methods defined here</h3>
<div class="container">
<div class="boxright">
<p><strong>Warning!</strong></p>
<p>You should be using the inbox/outbox interface, not these methods (except construction). This documentation is designed as a roadmap as to their functionalilty for maintainers and new component developers.</p>
</div>
</div>
<h4 id="init__self-messages_per_second-buffer-argd"><span id="symbol-MessageRateLimit.__init__">__init__(self, messages_per_second, buffer, **argd)</span></h4>
<p>x.__init__(...) initializes x; see x.__class__.__doc__ for signature</p>
<h4 id="mainself-1"><span id="symbol-MessageRateLimit.main">main(self)</span></h4>
<p>Main loop.</p>
<section>

</section>
<h1 id="kamaelia.util.ratefilter.ondemandlimit"><a href="/Components/pydoc/Kamaelia.html" class="reference">Kamaelia</a>.<a href="/Components/pydoc/Kamaelia.Util.html" class="reference">Util</a>.<a href="/Components/pydoc/Kamaelia.Util.RateFilter.html" class="reference">RateFilter</a>.<a href="/Components/pydoc/Kamaelia.Util.RateFilter.OnDemandLimit.html" class="reference">OnDemandLimit</a></h1>
<h2 id="symbol-OnDemandLimit">class OnDemandLimit(<a href="/Docs/Axon/Axon.Component.component.html" class="reference">Axon.Component.component</a>)</h2>
<p>OnDemandLimit() -&gt; new OnDemandLimit component.</p>
<p>A component that receives data items, but only emits them on demand, one at a time, when "NEXT" messages are received on the "slidecontrol" inbox.</p>
<h3 id="inboxes-2"><span id="symbol-OnDemandLimit.Inboxes">Inboxes</span></h3>
<ul>
<li><strong>control</strong> : Shutdown signalling</li>
<li><strong>inbox</strong> : Data items to be passed on, on demand.</li>
<li><strong>slidecontrol</strong> : 'NEXT' requests to emit a data item.</li>
</ul>
<h3 id="outboxes-2"><span id="symbol-OnDemandLimit.Outboxes">Outboxes</span></h3>
<ul>
<li><strong>outbox</strong> : Data items, when requested.</li>
<li><strong>signal</strong> : Shutdown signalling</li>
</ul>
<h3 id="methods-defined-here-2">Methods defined here</h3>
<div class="container">
<div class="boxright">
<p><strong>Warning!</strong></p>
<p>You should be using the inbox/outbox interface, not these methods (except construction). This documentation is designed as a roadmap as to their functionalilty for maintainers and new component developers.</p>
</div>
</div>
<h4 id="mainself-2"><span id="symbol-OnDemandLimit.main">main(self)</span></h4>
<p>Main loop.</p>
<section>

</section>
<h1 id="kamaelia.util.ratefilter.variablebyterate_requestcontrol"><a href="/Components/pydoc/Kamaelia.html" class="reference">Kamaelia</a>.<a href="/Components/pydoc/Kamaelia.Util.html" class="reference">Util</a>.<a href="/Components/pydoc/Kamaelia.Util.RateFilter.html" class="reference">RateFilter</a>.<a href="/Components/pydoc/Kamaelia.Util.RateFilter.VariableByteRate_RequestControl.html" class="reference">VariableByteRate_RequestControl</a></h1>
<h2 id="symbol-VariableByteRate_RequestControl">class VariableByteRate_RequestControl(<a href="/Docs/Axon/Axon.Component.component.html" class="reference">Axon.Component.component</a>)</h2>
<p>ByteRate_RequestControl([rate][,chunksize][,chunkrate][,allowchunkaggregation]) -&gt; new ByteRate_RequestControl component.</p>
<p>Controls rate of a data source by, at a controlled rate, emitting integers saying how much data to emit. Rate can be changed at runtime.</p>
<p>Keyword arguments: - rate -- qty of data items per second (default=100000) - chunksize -- None or qty of items per 'chunk' (default=None) - chunkrate -- None or number of chunks per second (default=10) - allowchunkaggregation -- if True, chunksize will be enlarged if 'catching up' is necessary (default=False)</p>
<p>Specify either chunksize or chunkrate, but not both.</p>
<h3 id="inboxes-3"><span id="symbol-VariableByteRate_RequestControl.Inboxes">Inboxes</span></h3>
<ul>
<li><strong>control</strong> : Shutdown signalling</li>
<li><strong>inbox</strong> : New rate</li>
</ul>
<h3 id="outboxes-3"><span id="symbol-VariableByteRate_RequestControl.Outboxes">Outboxes</span></h3>
<ul>
<li><strong>outbox</strong> : requests for 'n' items</li>
<li><strong>signal</strong> : Shutdown signalling</li>
</ul>
<h3 id="methods-defined-here-3">Methods defined here</h3>
<div class="container">
<div class="boxright">
<p><strong>Warning!</strong></p>
<p>You should be using the inbox/outbox interface, not these methods (except construction). This documentation is designed as a roadmap as to their functionalilty for maintainers and new component developers.</p>
</div>
</div>
<h4 id="init__self-rate-chunksize-chunkrate-allowchunkaggregation-1"><span id="symbol-VariableByteRate_RequestControl.__init__">__init__(self[, rate][, chunksize][, chunkrate][, allowchunkaggregation])</span></h4>
<p>x.__init__(...) initializes x; see x.__class__.__doc__ for signature</p>
<h4 id="changerateself-newrate-now"><span id="symbol-VariableByteRate_RequestControl.changeRate">changeRate(self, newRate, now)</span></h4>
<p>Change the rate.</p>
<p>Guaranteed to not cause a glitch in the rate of output.</p>
<h4 id="getchunkstosendself-now"><span id="symbol-VariableByteRate_RequestControl.getChunksToSend">getChunksToSend(self, now)</span></h4>
<p>Generator. Returns the size of chunks to be requested (if any) to 'catch up' since last time this method was called.</p>
<h4 id="mainself-3"><span id="symbol-VariableByteRate_RequestControl.main">main(self)</span></h4>
<p>Main loop.</p>
<h4 id="resettimingself-now"><span id="symbol-VariableByteRate_RequestControl.resetTiming">resetTiming(self, now)</span></h4>
<p>Resets the timing variable used to determine when the next time to send a request is.</p>
<h4 id="shutdownself-1"><span id="symbol-VariableByteRate_RequestControl.shutdown">shutdown(self)</span></h4>
<p>Returns True if shutdown message received.</p>
<section>

</section>
</section>
</div>
<h1 id="feedback">Feedback</h1>
<p>Got a problem with the documentation? Something unclear that could be clearer? Want to help improve it? Constructive criticism is very welcome - especially if you can suggest a better rewording!</p>
<p>Please leave you feedback <a href="../../../cgi-bin/blog/blog.cgi?rm=viewpost&amp;nodeid=1142023701" class="reference">here</a> in reply to the documentation thread in the Kamaelia blog.</p>
<p><em>-- Automatic documentation generator, 05 Jun 2009 at 03:01:38 UTC/GMT</em></p>

</div> <!-- end section -->
</div> <!-- end page container -->

<div class="banner">
<a href="https://www.bbc.co.uk/rd"><img src="/site-resources/BBCRD_Logo.jpg"></a>
<P id="mini">  Kamaelia is an open source project originated from and guided
by <a href="https://www.bbc.co.uk/rd">BBC Research.</a> For more information
browse the site or get in contact.
<br>This is an ongoing community based development site.  As a result the
contents of this page is the opinions of the contributors of the pages
involved not the organisations involved.  Specificially, this page may
contain personal views which are not the views of the BBC.

<br>(C) Copyright 2004-2024 Kamaelia Contributors, including the British
Broadcasting Corporation, All Rights Reserved.
</div>
</body>
</html>
