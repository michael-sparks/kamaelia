<html>
<head>
<title> index </title>
<link rel=stylesheet type="text/css" href="/site-resources/base.css">
<link rel=stylesheet type="text/css" href="/site-resources/pandoc.css">
</head>
<body>
<div class="banner">
<P> <a href="/Home.html">Home</a> | 
    <a href="/About.html">About</a> | 
    <a href="/RecentChanges.html">Recent Changes</a> | 
    <a href="/Documentation.html">Documentation</a> |
    <a href="/Community.html">Community</a>
</div>
<div class="pagecontainer">
<div class="pagesection">
<div id="pagenote">
<p>March 2024 - This site, and Kamaelia are <a href="https://github.com/sparkslabs/kamaelia/issues/15">being updated</a>. There is significant work needed, and <a href="https://github.com/sparkslabs/kamaelia/pulls">PRs</a> are welcome.
</div>
<div class="container">
<h1 id="kamaelia.support.particles.particlesystem"><a
href="/Components/pydoc/Kamaelia.html" class="reference">Kamaelia</a>.<a
href="/Components/pydoc/Kamaelia.Support.html"
class="reference">Support</a>.<a
href="/Components/pydoc/Kamaelia.Support.Particles.html"
class="reference">Particles</a>.<a
href="/Components/pydoc/Kamaelia.Support.Particles.ParticleSystem.html"
class="reference">ParticleSystem</a></h1>
<section>
<div class="container">

</div>
<ul>
<li><a href="#3" class="reference">Discrete time particle physics
simulation</a>
<ul>
<li><a href="#4" class="reference">Example Usage</a></li>
<li><a href="#5" class="reference">How does it work?</a></li>
</ul></li>
</ul>
</section>
<h1 id="3">Discrete time particle physics simulation</h1>
<p>A discrete time simulator of a system of bonded and unbonded
particles, of multiple types.</p>
<p>The actual physics calculations are deferred to the particles
themselves. You can have as many, or few, spatial dimensions as you
like.</p>
<h2 id="4"><span id="example-usage">Example Usage</span></h2>
<p>Create 3 particles, two of which are bonded and move noticeably
closer after 5 cycles of simulation:</p>
<pre class="literal-block"><code>&gt;&gt;&gt; laws = SimpleLaws(bondLength=5)
&gt;&gt;&gt; sim = ParticleSystem(laws)
&gt;&gt;&gt; sim.add( Particle(position=(10,10)) )
&gt;&gt;&gt; sim.add( Particle(position=(10,20)) )
&gt;&gt;&gt; sim.add( Particle(position=(30,40)) )
&gt;&gt;&gt; sim.particles[0].makeBond(sim.particles, 1)   # bond 1st and 2nd particles
&gt;&gt;&gt; for p in sim.particles: print p.getLoc()
...
(10, 10)
(10, 20)
(30, 40)
&gt;&gt;&gt; sim.run(cycles=5)
&gt;&gt;&gt; for p in sim.particles: print p.getLoc()
...
[10.0, 13.940067328]
[10.0, 16.059932671999999]
[30, 40]
&gt;&gt;&gt;</code></pre>
<h2 id="5"><span id="how-does-it-work">How does it work?</span></h2>
<p>Set up ParticleSystem by instantiating, specifying the laws to act
between particles and an (optional) set of initial particles.</p>
<p>Particles should be derived from the Particle base class (or have
equivalent functionality).</p>
<p>Particles can be added or removed from the system by reference, or
removed by their ID.</p>
<p>ParticleSystem will work for particles in space with any number of
dimensions - so long as all particles use the same!</p>
<p>Bonds between particles are up to the particles to manage for
themselves.</p>
<p>The simulation runs in cycles when the run(...) method is called.
Each cycle advances the 'tick' count by 1. The tick count starts at
zero, unless otherwise specified during initialization.</p>
<p>The following attributes store the particles registered in
ParticleSystem: - particles -- simple list - particleDict -- dictionary,
indexed by particle.ID</p>
<p>ParticleSystem uses a SpatialIndexer object to speed up calculations.
SpatialIndexer reduce the search space when determining what particles
lie within a given region (radius of a point).</p>
<p>If your code changes the position of a particle, the simulator must
be informed, so it can update its spatial indexing data, by calling
updateLoc(...)</p>
<p>The actual interactions between particles are calculated by the
particles themselves, <em>not</em> by ParticleSystem.</p>
<p>ParticleSystem calls the doInteractions(...) methods of all particles
so they can influence each other. It then calls the update(...) methods
of all particles so they can all update their positions and velocities
ready for the next cycle.</p>
<p>This is a two stage process so that, in a given cycle, all particles
see each other at the same positions, irrespective of which particle's
doInteractions(...) method is called first. Particles should not apply
their velocities to update their position until their update(...) method
is called.</p>
<hr />
<section>

</section>
</div>
<h1 id="feedback">Feedback</h1>
<p>Got a problem with the documentation? Something unclear that could be
clearer? Want to help improve it? Constructive criticism is very welcome
- especially if you can suggest a better rewording!</p>
<p>Please leave you feedback <a
href="../../../cgi-bin/blog/blog.cgi?rm=viewpost&amp;nodeid=1142023701"
class="reference">here</a> in reply to the documentation thread in the
Kamaelia blog.</p>
<p><em>-- Automatic documentation generator, 05 Jun 2009 at 03:01:38
UTC/GMT</em></p>

</div> <!-- end section -->
</div> <!-- end page container -->

<div class="banner">
<a href="https://www.bbc.co.uk/rd"><img src="/site-resources/BBCRD_Logo.jpg"></a>
<P id="mini">  Kamaelia is an open source project originated from and guided
by <a href="https://www.bbc.co.uk/rd">BBC Research.</a> For more information
browse the site or get in contact.
<br>This is an ongoing community based development site.  As a result the
contents of this page is the opinions of the contributors of the pages
involved not the organisations involved.  Specificially, this page may
contain personal views which are not the views of the BBC.

<br>(C) Copyright 2004-2024 Kamaelia Contributors, including the British
Broadcasting Corporation, All Rights Reserved.
</div>
</body>
</html>
