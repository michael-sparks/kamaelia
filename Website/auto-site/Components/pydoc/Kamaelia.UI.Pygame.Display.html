<html>
<head>
<title> index </title>
<link rel=stylesheet type="text/css" href="/site-resources/base.css">
<link rel=stylesheet type="text/css" href="/site-resources/pandoc.css">
</head>
<body>
<div class="banner">
<P> <a href="/Home.html">Home</a> | 
    <a href="/About.html">About</a> | 
    <a href="/RecentChanges.html">Recent Changes</a> | 
    <a href="/Documentation.html">Documentation</a> |
    <a href="/Community.html">Community</a>
</div>
<div class="pagecontainer">
<div class="pagesection">
<div id="pagenote">
<p>March 2024 - This site, and Kamaelia are <a href="https://github.com/sparkslabs/kamaelia/issues/15">being updated</a>. There is significant work needed, and <a href="https://github.com/sparkslabs/kamaelia/pulls">PRs</a> are welcome.
</div>
<div class="container">
<h1 id="kamaelia.ui.pygame.display"><a
href="/Components/pydoc/Kamaelia.html" class="reference">Kamaelia</a>.<a
href="/Components/pydoc/Kamaelia.UI.html" class="reference">UI</a>.<a
href="/Components/pydoc/Kamaelia.UI.Pygame.html"
class="reference">Pygame</a>.<a
href="/Components/pydoc/Kamaelia.UI.Pygame.Display.html"
class="reference">Display</a></h1>
<section>
<div class="container">
<ul>
<li><strong>component <a
href="/Components/pydoc/Kamaelia.UI.Pygame.Display.PygameDisplay.html"
class="reference">PygameDisplay</a></strong></li>
</ul>
</div>
<ul>
<li><a href="#392" class="reference">Pygame Display Access</a>
<ul>
<li><a href="#393" class="reference">Example Usage</a></li>
<li><a href="#394" class="reference">How does it work?</a>
<ul>
<li><a href="#395" class="reference">Surfaces</a></li>
<li><a href="#396" class="reference">Listening to events</a></li>
<li><a href="#397" class="reference">Video Overlays</a></li>
<li><a href="#398" class="reference">Redraw requests</a></li>
</ul></li>
<li><a href="#399" class="reference">Implementation Details</a></li>
</ul></li>
</ul>
</section>
<h1 id="392">Pygame Display Access</h1>
<p>This component provides a pygame window. Other components can request
to be notified of events, or ask for a pygame surface or video overlay
that will be rendered onto the display.</p>
<p>Pygame Display is a service that registers with the Coordinating
Assistant Tracker (CAT).</p>
<h2 id="393"><span id="example-usage">Example Usage</span></h2>
<p>See the Button component or VideoOverlay component for examples of
how Pygame Display can be used.</p>
<h2 id="394"><span id="how-does-it-work">How does it work?</span></h2>
<p>Pygame Display is a service. obtain it by calling the
PygameDisplay.getDisplayService(...) static method. Any existing
instance will be returned, otherwise a new one is automatically
created.</p>
<p>Alternatively, if you wish to configure Pygame Display with options
other than the defaults, create your own instance, then register it as a
service by calling the PygameDisplay.setDisplayService(...) static
method. NOTE that it is only advisable to do this at the top level of
your system, as other components may have already requested and created
a Pygame Display component!</p>
<p>pygame only supports one display window at a time, you must not make
more than one Pygame Display component.</p>
<p>Pygame Display listens for requests arriving at its "notify" inbox. A
request can be to: - create or destroy a surface, - listen or stop
listening to events (you must have already requested a surface) - move
an existing surface - create a video overlay - notify of ne to
redraw</p>
<p>The requests are described in more detail below.</p>
<p>Once your component has been given the requested surface, it is free
to render onto it whenever it wishes. It should then immediately send a
"REDRAW" request to notify Pygame Display that the window needs
redrawing.</p>
<p>NOTE that you must set the alpha value of the surface before
rendering and restore its previous value before yielding. This is
because Pygame Display uses the alpha value to control the transparency
with which it renders the surface.</p>
<p>Overlays work differently: instead of being given something to render
to, you must provide, in your initial request, an outbox to which you
will send raw yuv (video) data, whenever you want to change the image on
the overlay.</p>
<p>Pygame Display instantiates a private, threaded component to listen
for pygame events. These are then forwarded onto Pygame Display.</p>
<p>Pygame Display's main loop continuously renders the surfaces and
video overlays onto the display, and dispatches any pygame events to
listeners. The rendering order is as follows: - background fill
(default=white) - surfaces (in the order they were requested and
created) - video overlays (in the order they were requested and
created)</p>
<p>In summary, to use a surface, your component should: 1. Obtain and
wire up to the "notify" inbox of the Pygame Display service 2. Request a
surface 3. Render onto that surface in its main loop</p>
<p>And to use overlays, your component should: 1. Obtain and wire up to
the "notify" inbox of the Pygame Display service 2. Request an overlay,
providing an outbox 3. Send yuv data to the outbox</p>
<p>This component does not terminate. It ignores any messages arriving
at its "control" inbox and does not send anything out of its "outbox" or
"signal" outboxes.</p>
<h3 id="395"><span id="surfaces">Surfaces</span></h3>
<p>To request a surface, send a dictionary to the "notify" inbox. The
following keys are mandatory:</p>
<pre class="literal-block"><code>{
    &quot;DISPLAYREQUEST&quot; : True,               # this is a &#39;new surface&#39; request
    &quot;size&quot; : (width,height),               # pixels size for the new surface
    &quot;callback&quot; : (component, &quot;inboxname&quot;)  # to send the new surface object to
}</code></pre>
<p>These keys are optional:</p>
<pre class="literal-block"><code>{
    &quot;position&quot; : (left,top)                # location of the new surface in the window (default=arbitrary)
    &quot;alpha&quot; : 0 to 255,                    # alpha of the surface (255=opaque) (default=255)
    &quot;transparency&quot; : (r,g,b),              # colour that will appear transparent (default=None)
    &quot;events&quot; : (component, &quot;inboxname&quot;),   # to send event notification to (default=None)
}</code></pre>
<p>To deregister your surface, send a producerFinished(surface) message
to the "notify" inbox. Where 'surface' is your surface. This will remove
your surface and deregister any events you were listening to.</p>
<p>To change the position your surface is rendered at, send a dictionary
to the "notify" inbox containing the folling keys:</p>
<pre class="literal-block"><code>{
    &quot;CHANGEDISPLAYGEO&quot; : True,             # this is a &#39;change geometry&#39; request
    &quot;surface&quot; : surface,                   # the surface to affect
    &quot;position&quot; : (left,top)                # new location for the surface in the window
}</code></pre>
<p>The "surface" and "position" keys are optional. However if either are
not specified then there will be no effect!</p>
<h3 id="396"><span id="listening-to-events">Listening to
events</span></h3>
<p>Once your component has obtained a surface, it can request to be
notified of specific pygame events.</p>
<p>To request to listen to a given event, send a dictionary to the
"notify" inbox, containing the following:</p>
<pre class="literal-block"><code>{
    &quot;ADDLISTENEVENT&quot; : pygame_eventtype,     # example: pygame.KEYDOWN
    &quot;surface&quot; : your_surface,
}</code></pre>
<p>To unsubscribe from a given event, send a dictionary containing:</p>
<pre class="literal-block"><code>{
    &quot;REMOVELISTENEVENT&quot; : pygame_eventtype,
    &quot;surface&quot; : your_surface,
}</code></pre>
<p>Events will be sent to the inbox specified in the "events" key of the
"DISPLAYREQUEST" message. They arrive as a list of pygame event
objects.</p>
<p>NOTE: If the event is MOUSEMOTION, MOUSEBUTTONUP or MOUSEBUTTONDOWN
then you will instead receive a replacement object, with the same
attributes as the pygame event, but with the 'pos' attribute adjusted so
that (0,0) is the top left corner of <em>your</em> surface.</p>
<h3 id="397"><span id="video-overlays">Video Overlays</span></h3>
<p>To request an overlay, send a dictionary to the "notify" inbox. The
following keys are mandatory:</p>
<pre class="literal-block"><code>{
    &quot;OVERLAYREQUEST&quot; : True,                      # this is a &#39;new overlay&#39; request
    &quot;size&quot; : (width,height),                      # pixels size of the overlay
    &quot;pixformat&quot; : pygame_pixformat,               # example: pygame.IYUV_OVERLAY
}</code></pre>
<p>These keys are optional:</p>
<pre class="literal-block"><code>{
    &quot;position&quot; : (left,top),                      # location of the overlay (default=(0,0))
    &quot;yuv&quot; : (ydata,udata,vdata),                  # first frame of yuv data
    &quot;yuvservice&quot; : (component,&quot;outboxname&quot;),      # source of future frames of yuv data
    &quot;positionservice&quot; : (component,&quot;outboxname&quot;), # source of changes to the overlay position
}</code></pre>
<p>"yuv" enables you to provide the first frame of video data. It should
be 3 strings, containing the yuv data for a whole frame.</p>
<p>If you have supplied a (component,outbox) pair as a "yuvservice" then
any (y,u,v) data sent to that outbox will update the video overlay.
Again the data should be 3 strings, containing the yuv data for a
<em>whole frame</em>.</p>
<p>If you have supplied a "positionservice", then sending (x,y) pairs to
the outbox you specified will update the position of the overlay.</p>
<p>There is currently no mechanism to destroy an overlay.</p>
<h3 id="398"><span id="redraw-requests">Redraw requests</span></h3>
<p>To notify Pygame Display that it needs to redraw the display, send a
dictionary containing the following keys to the "notify" inbox:</p>
<pre class="literal-block"><code>{
    &quot;REDRAW&quot; : True,             # this is a redraw request
    &quot;surface&quot; : surface          # surface that has been changed
}</code></pre>
<h2 id="399"><span id="implementation-details">Implementation
Details</span></h2>
<p>You may notice that this module also contains a _PygameEventSource
component. PygameDisplay uses this separate threaded component to notify
it when pygame events occur - so that it can sleep quiescently when it
has nothing to do.</p>
<p>Unfortunately event handling itself cannot be done in the thread
since pygame on many platforms (particularly win32) does not work
properly if event handling and display creation is not done in the main
thread of the program.</p>
<hr />
<h1 id="kamaelia.ui.pygame.display.pygamedisplay"><a
href="/Components/pydoc/Kamaelia.html" class="reference">Kamaelia</a>.<a
href="/Components/pydoc/Kamaelia.UI.html" class="reference">UI</a>.<a
href="/Components/pydoc/Kamaelia.UI.Pygame.html"
class="reference">Pygame</a>.<a
href="/Components/pydoc/Kamaelia.UI.Pygame.Display.html"
class="reference">Display</a>.<a
href="/Components/pydoc/Kamaelia.UI.Pygame.Display.PygameDisplay.html"
class="reference">PygameDisplay</a></h1>
<h2 id="symbol-PygameDisplay">class PygameDisplay(<a
href="/Docs/Axon/Axon.AdaptiveCommsComponent.AdaptiveCommsComponent.html"
class="reference">Axon.AdaptiveCommsComponent.AdaptiveCommsComponent</a>)</h2>
<p>PygameDisplay(...) -&gt; new PygameDisplay component</p>
<p>Use PygameDisplay.getDisplayService(...) in preference as it returns
an existing instance, or automatically creates a new one.</p>
<p>Or create your own and register it with setDisplayService(...)</p>
<p>Keyword arguments (all optional):</p>
<ul>
<li>width -- pixels width (default=800)</li>
<li>height -- pixels height (default=600)</li>
<li>background_colour -- (r,g,b) background colour
(default=(255,255,255))</li>
<li>fullscreen -- set to True to start up fullscreen, not windowed
(default=False)</li>
</ul>
<h3 id="inboxes"><span
id="symbol-PygameDisplay.Inboxes">Inboxes</span></h3>
<ul>
<li><strong>control</strong> : NOT USED</li>
<li><strong>events</strong> : Receive events from source of pygame
events</li>
<li><strong>inbox</strong> : Default inbox, not currently used</li>
<li><strong>notify</strong> : Receive requests for surfaces, overlays
and events</li>
</ul>
<h3 id="outboxes"><span
id="symbol-PygameDisplay.Outboxes">Outboxes</span></h3>
<ul>
<li><strong>outbox</strong> : NOT USED</li>
<li><strong>signal</strong> : NOT USED</li>
</ul>
<h3 id="methods-defined-here">Methods defined here</h3>
<div class="container">
<div class="boxright">
<p><strong>Warning!</strong></p>
<p>You should be using the inbox/outbox interface, not these methods
(except construction). This documentation is designed as a roadmap as to
their functionalilty for maintainers and new component developers.</p>
</div>
</div>
<h4 id="init__self-argd"><span
id="symbol-PygameDisplay.__init__">__init__(self, **argd)</span></h4>
<p>x.__init__(...) initializes x; see x.__class__.__doc__ for
signature</p>
<h4 id="handledisplayrequestself"><span
id="symbol-PygameDisplay.handleDisplayRequest">handleDisplayRequest(self)</span></h4>
<p>Check "notify" inbox for requests for surfaces, events and overlays
and process them.</p>
<h4 id="handleeventsself"><span
id="symbol-PygameDisplay.handleEvents">handleEvents(self)</span></h4>
<h4 id="mainself"><span
id="symbol-PygameDisplay.main">main(self)</span></h4>
<p>Main loop.</p>
<h4 id="surfacepositionself-surface"><span
id="symbol-PygameDisplay.surfacePosition">surfacePosition(self,
surface)</span></h4>
<p>Returns a suggested position for a surface. No guarantees its any
good!</p>
<h4 id="updatedisplayself-display"><span
id="symbol-PygameDisplay.updateDisplay">updateDisplay(self,
display)</span></h4>
<p>Render all surfaces and overlays onto the specified display
surface.</p>
<p>Also dispatches events to event handlers.</p>
<h4 id="updateoverlaysself"><span
id="symbol-PygameDisplay.updateOverlays">updateOverlays(self)</span></h4>
<section>

</section>
</div>
<h1 id="feedback">Feedback</h1>
<p>Got a problem with the documentation? Something unclear that could be
clearer? Want to help improve it? Constructive criticism is very welcome
- especially if you can suggest a better rewording!</p>
<p>Please leave you feedback <a
href="../../../cgi-bin/blog/blog.cgi?rm=viewpost&amp;nodeid=1142023701"
class="reference">here</a> in reply to the documentation thread in the
Kamaelia blog.</p>
<p><em>-- Automatic documentation generator, 05 Jun 2009 at 03:01:38
UTC/GMT</em></p>

</div> <!-- end section -->
</div> <!-- end page container -->

<div class="banner">
<a href="https://www.bbc.co.uk/rd"><img src="/site-resources/BBCRD_Logo.jpg"></a>
<P id="mini">  Kamaelia is an open source project originated from and guided
by <a href="https://www.bbc.co.uk/rd">BBC Research.</a> For more information
browse the site or get in contact.
<br>This is an ongoing community based development site.  As a result the
contents of this page is the opinions of the contributors of the pages
involved not the organisations involved.  Specificially, this page may
contain personal views which are not the views of the BBC.

<br>(C) Copyright 2004-2024 Kamaelia Contributors, including the British
Broadcasting Corporation, All Rights Reserved.
</div>
</body>
</html>
