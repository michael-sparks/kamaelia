<html>
<head>
<title> index </title>
<link rel=stylesheet type="text/css" href="/site-resources/base.css">
<link rel=stylesheet type="text/css" href="/site-resources/pandoc.css">
</head>
<body>
<div class="banner">
<P> <a href="/Home.html">Home</a> | <a href="/About.html">About</a> | <a href="/Developers.html">Developers</a>
</div>
<div class="pagecontainer">
<div class="pagesection">
<div id="pagenote">
<p>Feb 2024 - This site, and Kamaelia are <a href="https://github.com/sparkslabs/kamaelia/issues/15">being updated</a>. There is significant work needed, and <a href="https://github.com/sparkslabs/kamaelia/pulls">PRs</a> are welcome.
</div>
<div class="container">
<h1 id="kamaelia.chassis.carousel"><a href="/Components/pydoc/Kamaelia.html" class="reference">Kamaelia</a>.<a href="/Components/pydoc/Kamaelia.Chassis.html" class="reference">Chassis</a>.<a href="/Components/pydoc/Kamaelia.Chassis.Carousel.html" class="reference">Carousel</a></h1>
<section>
<div class="container">
<ul>
<li><strong>component <a href="/Components/pydoc/Kamaelia.Chassis.Carousel.Carousel.html" class="reference">Carousel</a></strong></li>
</ul>
</div>
<ul>
<li><a href="#278" class="reference">Component Carousel Chassis</a>
<ul>
<li><a href="#279" class="reference">Example Usage</a></li>
<li><a href="#280" class="reference">Why is this useful?</a></li>
<li><a href="#281" class="reference">How does it work?</a></li>
</ul></li>
<li><a href="#282" class="reference">Test documentation</a></li>
</ul>
</section>
<section>
<h1 id="component-carousel-chassis-278">Component Carousel Chassis {#278}</h1>
<p>This component lets you create and wire up another component. You can then swap it for a new one by sending it a message. The message contents is used by a factory function to create the new replacement component.</p>
<p>The component that is created is a child contained within Carousel. Wire up to Carousel's "inbox" inbox and "outbox" outbox to send and receive messages from the child.</p>
<h2 id="example-usage-279"><span id="example-usage">Example Usage</span> {#279}</h2>
<p>A reusable file reader:</p>
<pre class="literal-block"><code>def makeFileReader(filename):
    return ReadFileAdapter(filename = filename, ...other args... )

reusableFileReader = Carousel(componentFactory = makeFileReader)</code></pre>
<p>Whenever you send a filename to the "next" inbox of the reusableFileReader component, it will read that file. You can do this as many times as you wish. The data read from the file comes out of the carousel's outbox.</p>
<p>Putting this re-usable file reader to use: the following simple example lets the user enter the names of files to read:</p>
<pre class="literal-block"><code>Graphline(
   FILENAME_INPUT = ConsoleReader(prompt=&quot;enter a filename&gt;&quot;),
   FILE_READER = Carousel(componentFactory = makeFileReader),
   OUTPUT = ConsoleEchoer(),
   linkages = {
       (&quot;FILENAME_INPUT&quot;, &quot;outbox&quot;) : (&quot;FILE_READER&quot;, &quot;next&quot;),
       (&quot;FILE_READER&quot;, &quot;outbox&quot;) : (&quot;OUTPUT&quot;, &quot;inbox&quot;),
   }).run()</code></pre>
<p>The user input causes the Carousel to replace the current file reader component (if it has not already terminated) with a new one. The output from this file reader is sent straight back to the console.</p>
<h2 id="why-is-this-useful-280"><span id="why-is-this-useful">Why is this useful?</span> {#280}</h2>
<p>This chassis component is for making a carousel of components. It gets its name from a broadcast carousel - where a programme (or set of programmes) is broadcast one after another, often on a loop. Alternatively, think of public information screens which display a looping carousel of slides of information.</p>
<p>You gain reusability from things that are not directly reusable and normally come to a halt. For example, make a carousel of file reader components, and you can read from more than one file, one after another. The carousel will make a new file reader component every time you make new request.</p>
<p>The Carousel automatically sends a "NEXT" message when a component finishes, to prompt you make a new request.</p>
<h2 id="how-does-it-work-281"><span id="how-does-it-work">How does it work?</span> {#281}</h2>
<p>The carousel chassis creates and encapsulates (as a child) the component you want it to, and lets it get on with it.</p>
<p>Anything sent to the carousel's "inbox" inbox is passed onto the child component. Anything the child sends out appears at the carousel's "outbox" outbox.</p>
<p>If the child terminates, then the carousel unwires it and sends a "NEXT" message out of its "requestNext" outbox (unless of course it has been told to shutdown).</p>
<p>Another component, such as a Chooser, can respond to this message by sending the new set of arguments (for the factory function) to the carousel's "next" inbox. The carousel then uses your factory function to create a new child component. This way, a sequence of operations can be automatically chained together.</p>
<p>If the argument source needs to receive a "NEXT" message before sending its first set of arguments, then set the argument make1stRequest=True when creating the carousel.</p>
<p>You can actually send new orders to the "next" inbox at any time, not just in response to requests from the Carousel. The carousel will immediately ask that child to terminate; then as soon as it has done so, it will create the new one and wire it in in its place.</p>
<p>If Carousel receives an <a href="/Docs/Axon/Axon.Ipc.producerFinished.html" class="reference">Axon.Ipc.producerFinished</a> message on its "control" inbox then it will finish handling any pending messages on its "next" inbox (in the way described above) then when there are none left, it will ask the child component to shut down by sending on the producerFinished message to the child. As soon as the child has terminated, the Carousel will terminate and send on the producerFinished message out of its own "signal" outbox.</p>
<p>If Carousel receives an <a href="/Docs/Axon/Axon.Ipc.shutdownMicroprocess.html" class="reference">Axon.Ipc.shutdownMicroprocess</a> message on its "control" inbox then it will immediately send it on to its child component to ask it to terminate. As soon as the child has termianted, the Carousel will terminate and send on the shutdownMicroprocess message out of its own "signal" outbox.</p>
<p>Of course, if the Carousel has no child at the time either shutdown request is received, it will immediately terminate and send on the message out of its "signal" outbox.</p>
<h1 id="test-documentation-282">Test documentation {#282}</h1>
<p>Tests passed:</p>
<ul>
<li>A shutdownMicroprocess or producerFinished message sent to the "control" inbox of the Carousel gets passed onto the "control" inbox of the child.</li>
<li>Carousel initialises. By default it does nothing.</li>
<li>If the make1stRequest argument is set to True at initialisation, Carousel sends a "NEXT" message out of its "requestNext" outbox after it has started up.</li>
<li>Carousel doesn't terminate (in response to producerFinished or shutdownMicroprocess) until the child has terminated.</li>
<li>If the child sends out a producerFinished or shutdownMicroprocess message out of its "signal" outbox; the Carousel does not send out a message from its "requestNext" outbox in response.</li>
<li>Messages coming out of the child's "signal" outbox are ignored. They do not emerge from the "signal" outbox of the Carousel.</li>
<li>When a child terminates; the Carousel sends a "NEXT" message out of its "requestNext" outbox.</li>
<li>Any mesasges sent out of the "outbox" outbox of a child emerges from the "outbox" outbox of the Carousel.</li>
<li>Any messages sent to the "inbox" inbox of the Carousel gets sent on tot the "inbox" inbox of the child component.</li>
<li>When a message is sent to the "next" inbox, the supplied factory function is run with that argument.</li>
<li>Messages sent to the "next" inbox trigger the factory function, leading to the creation and activation of a child component.</li>
<li>A message sent to the "next" inbox starts a new child; but only once the current child has terminated.</li>
<li>If a shutdownMicroprocess() is received, any messages queued on the 'next' inbox are discarded; and Carousel shuts down as soon as any current child has terminated.</li>
<li>If a producerFinished() is received, but there are still messages queued on the 'next' inbox, those messages are processed (and children created) first. *Then* the Carousel terminates.</li>
<li>When idle, with no child; a shutdownMicroprocess or producerFinished message will cause Carousel to terminate.</li>
<li>If a producerFinshed or shutdownMicroprocess is sent to a Carousel's "control" inbox, it is passed onto the child's "control" inbox.</li>
</ul>
</section>
<hr />
<h1 id="kamaelia.chassis.carousel.carousel"><a href="/Components/pydoc/Kamaelia.html" class="reference">Kamaelia</a>.<a href="/Components/pydoc/Kamaelia.Chassis.html" class="reference">Chassis</a>.<a href="/Components/pydoc/Kamaelia.Chassis.Carousel.html" class="reference">Carousel</a>.<a href="/Components/pydoc/Kamaelia.Chassis.Carousel.Carousel.html" class="reference">Carousel</a></h1>
<h2 id="symbol-Carousel">class Carousel(<a href="/Docs/Axon/Axon.Component.component.html" class="reference">Axon.Component.component</a>)</h2>
<p>Carousel(componentFactory,[make1stRequest]) -&gt; new Carousel component</p>
<p>Create a Carousel component that makes child components one at a time (in carousel fashion) using the supplied factory function.</p>
<p>Keyword arguments:</p>
<ul>
<li>componentFactory -- function that takes a single argument and returns a component</li>
<li>make1stRequest -- if True, Carousel will send an initial "NEXT" request. (default=False)</li>
</ul>
<h3 id="inboxes"><span id="symbol-Carousel.Inboxes">Inboxes</span></h3>
<ul>
<li><strong>control</strong> :</li>
<li><strong>inbox</strong> : child's inbox</li>
<li><strong>next</strong> : requests to replace child</li>
</ul>
<h3 id="outboxes"><span id="symbol-Carousel.Outboxes">Outboxes</span></h3>
<ul>
<li><strong>outbox</strong> : child's outbox</li>
<li><strong>signal</strong> :</li>
<li><strong>_signal</strong> : internal use: for sending 'shutdownMicroprocess' to child</li>
<li><strong>requestNext</strong> : for requesting new child component</li>
</ul>
<h3 id="methods-defined-here">Methods defined here</h3>
<div class="container">
<div class="boxright">
<p><strong>Warning!</strong></p>
<p>You should be using the inbox/outbox interface, not these methods (except construction). This documentation is designed as a roadmap as to their functionalilty for maintainers and new component developers.</p>
</div>
</div>
<h4 id="init__self-componentfactory-make1strequest"><span id="symbol-Carousel.__init__">__init__(self, componentFactory[, make1stRequest])</span></h4>
<p>x.__init__(...) initializes x; see x.__class__.__doc__ for signature</p>
<h4 id="checkcontrolself"><span id="symbol-Carousel.checkControl">checkControl(self)</span></h4>
<h4 id="handlechildterminationsself"><span id="symbol-Carousel.handleChildTerminations">handleChildTerminations(self)</span></h4>
<p>Unplugs any children that have terminated</p>
<h4 id="instantiatenewchildself-args"><span id="symbol-Carousel.instantiateNewChild">instantiateNewChild(self, args)</span></h4>
<h4 id="mainself"><span id="symbol-Carousel.main">main(self)</span></h4>
<h4 id="requestnextself"><span id="symbol-Carousel.requestNext">requestNext(self)</span></h4>
<p>Sends 'next' out the 'requestNext' outbox</p>
<h4 id="shutdownchildself-shutdownmsg"><span id="symbol-Carousel.shutdownChild">shutdownChild(self, shutdownMsg)</span></h4>
<section>

</section>
</div>
<h1 id="feedback">Feedback</h1>
<p>Got a problem with the documentation? Something unclear that could be clearer? Want to help improve it? Constructive criticism is very welcome - especially if you can suggest a better rewording!</p>
<p>Please leave you feedback <a href="../../../cgi-bin/blog/blog.cgi?rm=viewpost&amp;nodeid=1142023701" class="reference">here</a> in reply to the documentation thread in the Kamaelia blog.</p>
<p><em>-- Automatic documentation generator, 05 Jun 2009 at 03:01:38 UTC/GMT</em></p>

</div> <!-- end section -->
</div> <!-- end page container -->

<div class="banner">
<a href="https://www.bbc.co.uk/rd"><img src="/site-resources/BBCRD_Logo.jpg"></a>
<P id="mini">  Kamaelia is an open source project originated from and guided
by <a href="https://www.bbc.co.uk/rd">BBC Research.</a> For more information
browse the site or get in contact.
<br>This is an ongoing community based development site.  As a result the
contents of this page is the opinions of the contributors of the pages
involved not the organisations involved.  Specificially, this page may
contain personal views which are not the views of the BBC.

<br>(C) Copyright 2004-2024 Kamaelia Contributors, including the British
Broadcasting Corporation, All Rights Reserved.
</div>
</body>
</html>
