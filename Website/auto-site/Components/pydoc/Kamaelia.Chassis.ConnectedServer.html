<html>
<head>
<title> index </title>
<link rel=stylesheet type="text/css" href="/site-resources/base.css">
<link rel=stylesheet type="text/css" href="/site-resources/pandoc.css">
</head>
<body>
<div class="banner">
<P> <a href="/Home.html">Home</a> | 
    <a href="/About.html">About</a> | 
    <a href="/RecentChanges.html">Recent Changes</a> | 
    <a href="/Documentation.html">Documentation</a> |
    <a href="/Community.html">Community</a>
</div>
<div class="pagecontainer">
<div class="pagesection">
<div id="pagenote">
<p>March 2024 - This site, and Kamaelia are <a href="https://github.com/sparkslabs/kamaelia/issues/15">being updated</a>. There is significant work needed, and <a href="https://github.com/sparkslabs/kamaelia/pulls">PRs</a> are welcome.
</div>
<div class="container">
<h1 id="kamaelia.chassis.connectedserver"><a
href="/Components/pydoc/Kamaelia.html" class="reference">Kamaelia</a>.<a
href="/Components/pydoc/Kamaelia.Chassis.html"
class="reference">Chassis</a>.<a
href="/Components/pydoc/Kamaelia.Chassis.ConnectedServer.html"
class="reference">ConnectedServer</a></h1>
<section>
<div class="container">
<ul>
<li><strong>component <a
href="/Components/pydoc/Kamaelia.Chassis.ConnectedServer.ServerCore.html"
class="reference">ServerCore</a></strong></li>
<li><strong>component <a
href="/Components/pydoc/Kamaelia.Chassis.ConnectedServer.SimpleServer.html"
class="reference">SimpleServer</a></strong></li>
</ul>
</div>
<ul>
<li><a href="#268" class="reference">Connected Servers</a>
<ul>
<li><a href="#269" class="reference">Example Usage</a></li>
<li><a href="#270" class="reference">Why is this useful?</a></li>
<li><a href="#271" class="reference">Writing a protocol handler</a></li>
<li><a href="#272" class="reference">How does it work?</a></li>
<li><a href="#273" class="reference">History</a></li>
<li><a href="#274" class="reference">To do</a></li>
</ul></li>
</ul>
</section>
<h1 id="268">Connected Servers</h1>
<p>These 'chassis' style components are used to implementing connected
servers. The most common example of this is a server which runs on top
of the TCP. Examples include: a web server, email server, imap server,
game protocol server, etc.</p>
<p>At present, there are two variants of this: <em>ServerCore</em> and
<em>SimpleServer</em> (You are generally recommended to use
ServerCore)</p>
<p>Both of these revolve around building TCP based servers. They handle
the mechanics of creating the listening component, and when new
connections come in, creating instances of your protocol handler
components to handle the connections.</p>
<p>As a result, the primary arguments are the port to listen on and a
function call or class name that when called returns a component for
handling this connection.</p>
<p>Your protocol handler then receives data from a specific client on
its inbox "inbox" and sends data to that same client on its outbox
"outbox".</p>
<p>ServerCore passes additional information about the connection to the
function that creates the protocol handler. You are not required to do
anything with that information if you don't need to.</p>
<p>Aside from that, ServerCore &amp; SimpleServer are used in the same
way. (ServerCore is just an extension, and rationalisation of the older
simple server code).</p>
<p>There is more information here: <a
href="http://www.kamaelia.org/Cookbook/TCPSystems"
class="uri">http://www.kamaelia.org/Cookbook/TCPSystems</a></p>
<h2 id="269"><span id="example-usage">Example Usage</span></h2>
<p>A server using a simple echo protocol, that just echoes back anything
sent by the client. Becase the protocol has no need to know any details
of the connection, the SimpleServer component is used:</p>
<pre class="literal-block"><code>import Axon
from Kamaelia.Chassis.ConnectedServer import SimpleServer

PORTNUMBER = 12345
class EchoProtocol(Axon.Component.component):

    def main(self):
        while not self.shutdown():
            yield 1
            if self.dataReady(&quot;inbox&quot;):
                data = self.recv(&quot;inbox&quot;)
                self.send(data, &quot;outbox&quot;)

    def shutdown(self):
        if self.dataReady(&quot;control&quot;):
            msg = self.recv(&quot;control&quot;)
            return isinstance(msg, Axon.Ipc.producerFinished)

simpleServer = SimpleServer( protocol = EchoProtocol, port = PORTNUMBER )
simpleServer.run()</code></pre>
<p>Try connecting to this server using the telnet command, and it will
echo back to you every character you type.</p>
<p>A more complex server might need to inform the protocol of the IP
address and port of the client that connects, or the ip address and port
at this (the server end) to which the client has connected. For this,
ServerCore is used:</p>
<pre class="literal-block"><code>import Axon
from Axon.Ipc import shutdownMicroprocess
from Kamaelia.Chassis.ConnectedServer import ServerCore

PORTNUMBER = 12345
class CleverEchoProtocol(Axon.Component.component):

    def main(self):
        welcomeMessage =                 &quot;Welcome! You have connected to %s on port %d from %s on port %d&quot; %                 (self.localip, self.localport, self.peer, self.peerport)

        self.send(welcomeMessage, &quot;outbox&quot;)
        while not self.shutdown():
            yield 1
            if self.dataReady(&quot;inbox&quot;):
                data = self.recv(&quot;inbox&quot;)
                self.send(data, &quot;outbox&quot;)

    def shutdown(self):
        if self.dataReady(&quot;control&quot;):
            msg = self.recv(&quot;control&quot;)
            return isinstance(msg, Axon.Ipc.producerFinished)

myServer = ServerCore( protocol = CleverEchoProtocol, port = PORTNUMBER )
myServer.run()</code></pre>
<p>Example output when telnetting to this more complex server, assuming
both server and telnet session are running on the same host, and the
server is listening to port number 8081:</p>
<pre class="literal-block"><code>$ telnet localhost 8081
Trying 127.0.0.1...
Connected to localhost.
Escape character is &#39;^]&#39;.
Welcome! You have connected to 127.0.0.1 on port 8081 from 127.0.0.1 on port 47316</code></pre>
<h2 id="270"><span id="why-is-this-useful">Why is this
useful?</span></h2>
<p>Provides a framework for creating generic protocol handlers to deal
with information coming in on a single port (and a single port only).
This however covers a large array of server types.</p>
<p>A protocol handler is simply a component that can receive and send
data (as byte strings) in a particular format and with a particular
behaviour - ie. conforming to a particular protocol.</p>
<p>Provide this chassis with a factory function to create a component to
handle the protocol. Whenever a client connects a handler component will
then be created to handle communications with that client.</p>
<p>Data received from the client will be sent to the protocol handler
component's "inbox" inbox. To send data back to the client, the protocol
handler component should send it out of its "outbox" outbox.</p>
<p>For the SingleServer component, the factory function takes no
arguments. It should simply return the component that will be used to
handle the protocol, for example:</p>
<pre class="literal-block"><code>def makeNewProtocolHandler():
    return MyProtocolComponent()</code></pre>
<p>For the ServerCore component, the factory function must accept the
following arguments (with these names):</p>
<ul>
<li>peer -- the address of the remote endpoint (the client's
address)</li>
<li>peerport -- the port number of the remote endpoint (the port number
from which the client connection originated)</li>
<li>localip -- the address of the local endpoint (this end of the
connection)</li>
<li>localport -- the port number of the local endpoint (this end of the
connection)</li>
</ul>
<p>For example:</p>
<pre class="literal-block"><code>def makeNewProtocolHandler(peer, peerport, localip, localport):
    print &quot;Debugging: client at address &quot;+peer+&quot; on port &quot;+str(peerport)
    print &quot; ... has connected to address &quot;+localip+&quot; on port &quot;+str(localport)
    return MyProtocolComponent()</code></pre>
<p>Do not activate the component. SingleServer or ServerCore will do
this once the component is wired up.</p>
<h2 id="271"><span id="writing-a-protocol-handler">Writing a protocol
handler</span></h2>
<p>A protocol handler component should use its standard inboxes ("inbox"
and "control") and outboxes ("outbox" and "signal") to communicate with
client it is connected to.</p>
<ul>
<li>Bytes received from the client will be sent to the "inbox" inbox as
a string.</li>
<li>Send a string out of the "outbox" outbox to send bytes back to the
client.</li>
</ul>
<p>If the connection is closed, a Kamaelia.IPC.socketShutdown message
will arrive at the protocol handler's "control" inbox. If this happens
then the connection should be assumed to have already closed. Any more
messages sent will not be sent to the client. The protocol handler
should react by terminating as soon as possible.</p>
<p>To cause the connection to close, send a producerFinished or
shutdownMicroprocess message out of the protocol handler's "signal"
outbox. As soon as this has been done, it can be assumed that the
connection will be closed as soon as is practical. The protocol handler
will probably also want to terminate at this point.</p>
<h2 id="272"><span id="how-does-it-work">How does it work?</span></h2>
<p>SimpleServer is based on ServerCore. It simply contains a wrapper
around the protocol handler function that throws away the connection
information instead of passing it in as arguments.</p>
<p>At initialisation the component registers a TCPServer component to
listen for new connections on the specified port.</p>
<p>You supply a factory function that takes no arguments and returns a
new protocol handler component.</p>
<p>When it receives a 'newCSA' message from the TCPServer (via the
"_socketactivity" inbox), the factory function is called to create a new
protocol handler. The protocol handler's "inbox" inbox and "outbox"
outbox are wired to the ConnectedSocketAdapter (CSA) component handling
that socket connection, so it can receive and send data.</p>
<p>If a 'shutdownCSA' message is received (via "_socketactivity") then a
Kamaelia.IPC.socketShutdown message is sent to the protocol handler's
"control" inbox, and both it and the CSA are unwired.</p>
<p>This component does not terminate. It ignores any messages sent to
its "control" inbox.</p>
<p>In practice, this component provides no external connectors for your
use.</p>
<h2 id="273"><span id="history">History</span></h2>
<p>This code is based on the code used for testing the Internet
Connection abstraction layer.</p>
<h2 id="274"><span id="to-do">To do</span></h2>
<p>This component currently lacks an inbox and corresponding code to
allow it to be shut down (in a controlled fashion). Needs a "control"
inbox that responds to shutdownMicroprocess messages.</p>
<hr />
<section>
<h1 id="kamaelia.chassis.connectedserver.servercore"><a
href="/Components/pydoc/Kamaelia.html" class="reference">Kamaelia</a>.<a
href="/Components/pydoc/Kamaelia.Chassis.html"
class="reference">Chassis</a>.<a
href="/Components/pydoc/Kamaelia.Chassis.ConnectedServer.html"
class="reference">ConnectedServer</a>.<a
href="/Components/pydoc/Kamaelia.Chassis.ConnectedServer.ServerCore.html"
class="reference">ServerCore</a></h1>
<h2 id="symbol-ServerCore">class ServerCore(<a
href="/Docs/Axon/Axon.AdaptiveCommsComponent.AdaptiveCommsComponent.html"
class="reference">Axon.AdaptiveCommsComponent.AdaptiveCommsComponent</a>)</h2>
<p>ServerCore(protocol[,port]) -&gt; new Simple protocol server
component</p>
<p>A simple single port, multiple connection server, that instantiates a
protocol handler component to handle each connection. The function that
creates the protocol must access arguments providing information about
the connection.</p>
<p>Keyword arguments:</p>
<ul>
<li>protocol -- function that returns a protocol handler component</li>
<li>port -- Port number to listen on for connections (default=1601)</li>
</ul>
<h3 id="inboxes"><span
id="symbol-ServerCore.Inboxes">Inboxes</span></h3>
<ul>
<li><strong>control</strong> : We expect to get serverShutdown messages
here</li>
<li><strong>_socketactivity</strong> : Messages about new and closing
connections here</li>
</ul>
<h3 id="outboxes"><span
id="symbol-ServerCore.Outboxes">Outboxes</span></h3>
<ul>
<li><strong>_serversignal</strong> : we send shutdown messages to the
TCP server here</li>
</ul>
<h3 id="methods-defined-here">Methods defined here</h3>
<div class="container">
<div class="boxright">
<p><strong>Warning!</strong></p>
<p>You should be using the inbox/outbox interface, not these methods
(except construction). This documentation is designed as a roadmap as to
their functionalilty for maintainers and new component developers.</p>
</div>
</div>
<h4 id="init__self-argd"><span
id="symbol-ServerCore.__init__">__init__(self, **argd)</span></h4>
<p>x.__init__(...) initializes x; see x.__class__.__doc__ for
signature</p>
<h4 id="handleclosedcsaself-shutdowncsamessage"><span
id="symbol-ServerCore.handleClosedCSA">handleClosedCSA(self,
shutdownCSAMessage)</span></h4>
<p>handleClosedCSA(shutdownCSAMessage) -&gt; None</p>
<p>Terminates and unwires the protocol handler for the closing
socket.</p>
<p>Keyword arguments: shutdownCSAMessage -- shutdownCSAMessage.object is
the ConnectedSocketAdapter for socket that is closing.</p>
<h4 id="handlenewconnectionself-newcsamessage"><span
id="symbol-ServerCore.handleNewConnection">handleNewConnection(self,
newCSAMessage)</span></h4>
<p>handleNewConnection(newCSAMessage) -&gt; <a
href="/Docs/Axon/Axon.Ipc.newComponent.html"
class="reference">Axon.Ipc.newComponent</a>(protocol handler)</p>
<p>Creates and returns a protocol handler for new connection.</p>
<p>Keyword arguments:</p>
<ul>
<li>newCSAMessage -- newCSAMessage.object is the ConnectedSocketAdapter
component for the connection</li>
</ul>
<h4 id="initialiseserversocketself"><span
id="symbol-ServerCore.initialiseServerSocket">initialiseServerSocket(self)</span></h4>
<h4 id="mainself"><span
id="symbol-ServerCore.main">main(self)</span></h4>
<h4 id="mkprotocolhandlerself-sock_info"><span
id="symbol-ServerCore.mkProtocolHandler">mkProtocolHandler(self,
**sock_info)</span></h4>
<h4 id="stopself"><span
id="symbol-ServerCore.stop">stop(self)</span></h4>
<section>

</section>
<h1 id="kamaelia.chassis.connectedserver.simpleserver"><a
href="/Components/pydoc/Kamaelia.html" class="reference">Kamaelia</a>.<a
href="/Components/pydoc/Kamaelia.Chassis.html"
class="reference">Chassis</a>.<a
href="/Components/pydoc/Kamaelia.Chassis.ConnectedServer.html"
class="reference">ConnectedServer</a>.<a
href="/Components/pydoc/Kamaelia.Chassis.ConnectedServer.SimpleServer.html"
class="reference">SimpleServer</a></h1>
<h2 id="symbol-SimpleServer">class SimpleServer(ServerCore)</h2>
<p>SimpleServer(protocol[,port]) -&gt; new Simple protocol server
component</p>
<p>A simple single port, multiple connection server, that instantiates a
protocol handler component to handle each connection.</p>
<p>Keyword arguments:</p>
<ul>
<li>protocol -- function that returns a protocol handler component</li>
<li>port -- Port number to listen on for connections (default=1601)</li>
</ul>
<h3 id="inboxes-1"><span
id="symbol-SimpleServer.Inboxes">Inboxes</span></h3>
<h3 id="outboxes-1"><span
id="symbol-SimpleServer.Outboxes">Outboxes</span></h3>
<h3 id="methods-defined-here-1">Methods defined here</h3>
<div class="container">
<div class="boxright">
<p><strong>Warning!</strong></p>
<p>You should be using the inbox/outbox interface, not these methods
(except construction). This documentation is designed as a roadmap as to
their functionalilty for maintainers and new component developers.</p>
</div>
</div>
<h4 id="init__self-argd-1"><span
id="symbol-SimpleServer.__init__">__init__(self, **argd)</span></h4>
<h4 id="mkprotocolhandlerself-sock_info-1"><span
id="symbol-SimpleServer.mkProtocolHandler">mkProtocolHandler(self,
**sock_info)</span></h4>
<section>
<h4
id="methods-inherited-from-kamaelia.chassis.connectedserver.morecomplexserver">Methods
inherited from <a
href="/Components/pydoc/Kamaelia.Chassis.ConnectedServer.MoreComplexServer.html"
class="reference">Kamaelia.Chassis.ConnectedServer.MoreComplexServer</a>
:</h4>
<ul>
<li><a
href="/Components/pydoc/Kamaelia.Chassis.ConnectedServer.html#symbol-MoreComplexServer.handleNewConnection"
class="reference">handleNewConnection</a>(self, newCSAMessage)</li>
<li><a
href="/Components/pydoc/Kamaelia.Chassis.ConnectedServer.html#symbol-MoreComplexServer.stop"
class="reference">stop</a>(self)</li>
<li><a
href="/Components/pydoc/Kamaelia.Chassis.ConnectedServer.html#symbol-MoreComplexServer.initialiseServerSocket"
class="reference">initialiseServerSocket</a>(self)</li>
<li><a
href="/Components/pydoc/Kamaelia.Chassis.ConnectedServer.html#symbol-MoreComplexServer.handleClosedCSA"
class="reference">handleClosedCSA</a>(self, shutdownCSAMessage)</li>
<li><a
href="/Components/pydoc/Kamaelia.Chassis.ConnectedServer.html#symbol-MoreComplexServer.main"
class="reference">main</a>(self)</li>
</ul>
</section>
</section>
</div>
<h1 id="feedback">Feedback</h1>
<p>Got a problem with the documentation? Something unclear that could be
clearer? Want to help improve it? Constructive criticism is very welcome
- especially if you can suggest a better rewording!</p>
<p>Please leave you feedback <a
href="../../../cgi-bin/blog/blog.cgi?rm=viewpost&amp;nodeid=1142023701"
class="reference">here</a> in reply to the documentation thread in the
Kamaelia blog.</p>
<p><em>-- Automatic documentation generator, 05 Jun 2009 at 03:01:38
UTC/GMT</em></p>

</div> <!-- end section -->
</div> <!-- end page container -->

<div class="banner">
<a href="https://www.bbc.co.uk/rd"><img src="/site-resources/BBCRD_Logo.jpg"></a>
<P id="mini">  Kamaelia is an open source project originated from and guided
by <a href="https://www.bbc.co.uk/rd">BBC Research.</a> For more information
browse the site or get in contact.
<br>This is an ongoing community based development site.  As a result the
contents of this page is the opinions of the contributors of the pages
involved not the organisations involved.  Specificially, this page may
contain personal views which are not the views of the BBC.

<br>(C) Copyright 2004-2024 Kamaelia Contributors, including the British
Broadcasting Corporation, All Rights Reserved.
</div>
</body>
</html>
