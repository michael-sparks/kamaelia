<html>
<head>
<title> index </title>
<link rel=stylesheet type="text/css" href="/site-resources/base.css">
<link rel=stylesheet type="text/css" href="/site-resources/pandoc.css">
</head>
<body>
<div class="banner">
<P> <a href="/Home.html">Home</a> | 
    <a href="/About.html">About</a> | 
    <a href="/RecentChanges.html">Recent Changes</a> | 
    <a href="/Documentation.html">Documentation</a> |
    <a href="/Community.html">Community</a>
</div>
<div class="pagecontainer">
<div class="pagesection">
<div id="pagenote">
<p>Feb 2024 - This site, and Kamaelia are <a href="https://github.com/sparkslabs/kamaelia/issues/15">being updated</a>. There is significant work needed, and <a href="https://github.com/sparkslabs/kamaelia/pulls">PRs</a> are welcome.
</div>
<div class="container">
<h1 id="kamaelia.util.splitter"><a href="/Components/pydoc/Kamaelia.html" class="reference">Kamaelia</a>.<a href="/Components/pydoc/Kamaelia.Util.html" class="reference">Util</a>.<a href="/Components/pydoc/Kamaelia.Util.Splitter.html" class="reference">Splitter</a></h1>
<section>
<div class="container">
<ul>
<li><strong>component <a href="/Components/pydoc/Kamaelia.Util.Splitter.Plug.html" class="reference">Plug</a></strong></li>
<li><strong>component <a href="/Components/pydoc/Kamaelia.Util.Splitter.PlugSplitter.html" class="reference">PlugSplitter</a></strong></li>
<li><strong>component <a href="/Components/pydoc/Kamaelia.Util.Splitter.Splitter.html" class="reference">Splitter</a></strong></li>
</ul>
</div>
<ul>
<li><a href="#191" class="reference">Simple Fanout of messages</a>
<ul>
<li><a href="#192" class="reference">Example Usage</a></li>
<li><a href="#193" class="reference">How does it work?</a></li>
</ul></li>
<li><a href="#194" class="reference">Pluggable Fanout of messages</a>
<ul>
<li><a href="#195" class="reference">Example Usage</a></li>
<li><a href="#196" class="reference">How does it work?</a></li>
</ul></li>
<li><a href="#197" class="reference">Plug for PlugSplitter</a>
<ul>
<li><a href="#198" class="reference">Example Usage</a></li>
<li><a href="#199" class="reference">How does it work?</a></li>
<li><a href="#200" class="reference">Thoughts</a></li>
</ul></li>
</ul>
</section>
<section>
<h2 id="simple-fanout-of-messages-191"><span id="simple-fanout-of-messages">Simple Fanout of messages</span> {#191}</h2>
<p>A component that splits a data source, fanning it out to multiple destinations.</p>
<h3 id="example-usage-192"><span id="example-usage">Example Usage</span> {#192}</h3>
<p>Component connecting to a Splitter:</p>
<pre class="literal-block"><code>class Consumer(Axon.Component.component):
    Outboxes = [ &quot;outbox&quot;, &quot;signal&quot;, &quot;splitter_config&quot; ]

    def main(self):
         self.send( addsink( self, &quot;inbox&quot;, &quot;control&quot; ), &quot;splitter_config&quot;)
         yield 1
         ... do stuff when data is received on &quot;inbox&quot; inbox

mysplitter = Splitter()
Pipeline( producer(), mysplitter ).activate()

myconsumer = Consumer().activate()
myconsumer.link( (myconsumer, &quot;splitter_config&quot;), (&quot;mysplitter&quot;, &quot;configuration&quot;) )</code></pre>
<h3 id="how-does-it-work-193"><span id="how-does-it-work">How does it work?</span> {#193}</h3>
<p>Any data sent to the component's "inbox" inbox is sent out to multiple destinations (but not to the "outbox" outbox).</p>
<p>Add a destination by sending an addsink(...) message to the "configuration" inbox of the component. Splitter will then wire up to the 'sinkbox' inbox specified in the message, and send it any data sent to its "inbox" inbox.</p>
<p>NOTE: Splitter only does this for the 'sinkbox' inbox, not for the 'sinkcontrol' inbox. If one is specified, it is ignored.</p>
<p>There is no limit on the number of 'sinks' that can be connected to the splitter. The same component can add itself as a sink multiple times, provided different named inboxes are used each time.</p>
<p>NOTE: The data is not duplicated - the same item is sent to all destinations. Care must therefore be taken if the data item is mutable.</p>
<p>If one or more destinations cause a noSpaceInBox exception, the data item will be queued, and Splitter will attempt to resend it to the destinations in question until successful. It will stop forwarding any new incoming data until it has succeeded, thereby ensuring the order of data is not altered.</p>
<p>Stop data being sent to a destination by sending a removesink(...) message to the "configuration" inbox of the Splitter component. Splitter will then cease sending messages to the 'sinkbox' inbox specified in the message and will unwire from it.</p>
<p>Any messages sent to the "control" inbox are ignored. The "outbox" and "signal" outboxes are not used.</p>
<p>This component does not terminate.</p>
<h2 id="pluggable-fanout-of-messages-194"><span id="pluggable-fanout-of-messages">Pluggable Fanout of messages</span> {#194}</h2>
<p>The PlugSplitter component splits a data source, fanning it out to multiple destinations. The Plug component allows you to easily 'plug' a destination into the splitter.</p>
<h3 id="example-usage-195"><span id="id1">Example Usage</span> {#195}</h3>
<p>Two consumers receiving the same data from a single consumer. Producer and consumers are encapsulated by PlugSplitter and Plug components respectively:</p>
<pre class="literal-block"><code>mysplitter = PlugSplitter( producer() ).activate()

Plug(mysplitter, consumer() ).activate()
Plug(mysplitter, consumer() ).activate()</code></pre>
<p>The same, but the producer and consumers are not encapsulated:</p>
<pre class="literal-block"><code>mysplitter = PlugSplitter()
Pipeline( producer, mysplitter ).activate()

Pipeline( Plug(mysplitter), consumer() ).activate()
Pipeline( Plug(mysplitter), consumer() ).activate()</code></pre>
<h3 id="how-does-it-work-196"><span id="id2">How does it work?</span> {#196}</h3>
<p>Any data sent to the component's "inbox" and "control" inboxes is sent out to multiple destinations. It is also sent onto the components "outbox" and "signal" outboxes, respectively.</p>
<p>Alternatively, initialisation you can specify a 'source' component. If you do, then data to be sent out to multiple destinations is instead received from that component's "outbox" and "signal" outboxes, respectively. Any data sent to the "inbox" and "control" inboxes of the PlugSplitter component will be forwarded to the "inbox" and "control" inboxes of the 'source' component, respectively.</p>
<p>This source component is encapsulated as a child within the PlugSplitter component, and so must not be separately activated. Activating PlugSplitter will also activate this child component.</p>
<p>Add a destination by making a Plug component, specifying the PlugSplitter component to 'plug into'. See documentation for the Plug component for more information.</p>
<p>Alternatively, you can add and remove destinations manually:</p>
<ul>
<li><p>Add a destination by sending an addsink(...) message to the "configuration" inbox of the component.</p>
<p>If a 'sinkbox' inbox is specified in the message, then PlugSplitter will wire up to it and forward to it any 'inbox'/'outbox' data. If a 'sinkcontrol' inbox is specified, then Plugsplitter will wire up to it and forward to it any 'control'/'signal' data.</p></li>
<li><p>Stop data being sent to a destination by sending a removesink(...) message to the "configuration" inbox of the Splitter component.</p>
<p>Splitter will then cease sending messages to the 'sinkbox' inbox specified in the message and will unwire from it.</p></li>
</ul>
<p>There is no limit on the number of 'sinks' that can be connected to the splitter. The same component can add itself as a sink multiple times, provided different named inboxes are used each time.</p>
<p>NOTE: The data is not duplicated - the same item is sent to all destinations. Care must therefore be taken if the data item is mutable.</p>
<p>If a shutdownMicroprocess or producerFinished message is received on the "control" inbox and there is NO 'source' child component, then the message is forwarded onto all 'control' destinations and the 'signal' outbox. The component then immediately terminates, unwiring from all destinations.</p>
<p>If there is a child component then PlugSplitter will terminate when the child component terminates, unwiring from all destinations.</p>
<h2 id="plug-for-plugsplitter-197"><span id="plug-for-plugsplitter">Plug for PlugSplitter</span> {#197}</h2>
<p>The Plug component 'plugs into' a PlugSplitter as a destination to which the source data is split.</p>
<h3 id="example-usage-198"><span id="id3">Example Usage</span> {#198}</h3>
<p>See PlugSplitter documentation.</p>
<h3 id="how-does-it-work-199"><span id="id4">How does it work?</span> {#199}</h3>
<p>Initialise the Plug component by specifying a PlugSplitter component to connect to and the component that wants to receive the data from the Plugsplitter.</p>
<p>The destination/sink component is encapsulated as a child component, and is therefore activated by the Plug component when it is activated. Do not activate it yourself.</p>
<p>The Plug component connects to the PlugSplitter component by wiring its "splitter_config" outbox to the "configuration" inbox of the PlugSplitter component and sending it an addsink(...) message. This causes PlugSplitter to wire up to the Plug's "inbox" and "control" inboxes.</p>
<p>The Plug's "inbox" and "control" inboxes are forwarded to the "inbox" and "control" inboxes of the child component respectively. The "outbox" and "signal" outboxes of the child component are forwarded to the "outbox" and "signal" outboxes of the Plug component respectively.</p>
<p>When the child component terminates, the Plug component sends a removesink(...) message to the PlugSplitter, causing PlugSplitter to unwire from it. It then terminates.</p>
<h3 id="thoughts-200"><span id="thoughts">Thoughts</span> {#200}</h3>
<p>PlugSplitter is probably more reliable than Splitter however it <em>feels</em> too complex. However the actual "Splitter" class in this file is not the preferable option.</p>
</section>
<hr />
<section>
<h1 id="kamaelia.util.splitter.plug"><a href="/Components/pydoc/Kamaelia.html" class="reference">Kamaelia</a>.<a href="/Components/pydoc/Kamaelia.Util.html" class="reference">Util</a>.<a href="/Components/pydoc/Kamaelia.Util.Splitter.html" class="reference">Splitter</a>.<a href="/Components/pydoc/Kamaelia.Util.Splitter.Plug.html" class="reference">Plug</a></h1>
<h2 id="symbol-Plug">class Plug(<a href="/Docs/Axon/Axon.Component.component.html" class="reference">Axon.Component.component</a>)</h2>
<p>Plug(splitter,component) -&gt; new Plug component.</p>
<p>A component that 'plugs' the specified component into the specified splitter as a destination for data.</p>
<p>Keyword arguments:</p>
<ul>
<li>splitter -- splitter component to plug into (any component that accepts addsink(...) and removesink(...) messages on a 'configuration' inbox</li>
<li>component -- component to receive data from the splitter</li>
</ul>
<h3 id="inboxes"><span id="symbol-Plug.Inboxes">Inboxes</span></h3>
<ul>
<li><strong>control</strong> : Incoming control data for child component, and shutdown signalling</li>
<li><strong>inbox</strong> : Incoming data for child component</li>
</ul>
<h3 id="outboxes"><span id="symbol-Plug.Outboxes">Outboxes</span></h3>
<ul>
<li><strong>outbox</strong> : Outgoing data from child component</li>
<li><strong>signal</strong> : Outgoing control data from child component, and shutdown signalling</li>
<li><strong>splitter_config</strong> : Used to communicate with the target splitter</li>
</ul>
<h3 id="methods-defined-here">Methods defined here</h3>
<div class="container">
<div class="boxright">
<p><strong>Warning!</strong></p>
<p>You should be using the inbox/outbox interface, not these methods (except construction). This documentation is designed as a roadmap as to their functionalilty for maintainers and new component developers.</p>
</div>
</div>
<h4 id="init__self-splitter-component"><span id="symbol-Plug.__init__">__init__(self, splitter, component)</span></h4>
<p>x.__init__(...) initializes x; see x.__class__.__doc__ for signature</p>
<h4 id="childrendoneself"><span id="symbol-Plug.childrenDone">childrenDone(self)</span></h4>
<p>Unplugs any children that have terminated, and returns true if there are no running child components left (ie. their microproceses have finished)</p>
<h4 id="mainself"><span id="symbol-Plug.main">main(self)</span></h4>
<p>Main loop.</p>
<section>

</section>
<h1 id="kamaelia.util.splitter.plugsplitter"><a href="/Components/pydoc/Kamaelia.html" class="reference">Kamaelia</a>.<a href="/Components/pydoc/Kamaelia.Util.html" class="reference">Util</a>.<a href="/Components/pydoc/Kamaelia.Util.Splitter.html" class="reference">Splitter</a>.<a href="/Components/pydoc/Kamaelia.Util.Splitter.PlugSplitter.html" class="reference">PlugSplitter</a></h1>
<h2 id="symbol-PlugSplitter">class PlugSplitter(<a href="/Docs/Axon/Axon.AdaptiveCommsComponent.AdaptiveCommsComponent.html" class="reference">Axon.AdaptiveCommsComponent.AdaptiveCommsComponent</a>)</h2>
<p>PlugSplitter([sourceComponent]) -&gt; new PlugSplitter component.</p>
<p>Splits incoming data out to multiple destinations. Send addsink(...) and removesink(...) messages to the 'configuration' inbox to add and remove destinations.</p>
<p>Keyword arguments:</p>
<ul>
<li>sourceComponent -- None, or component to act as data source</li>
</ul>
<h3 id="inboxes-1"><span id="symbol-PlugSplitter.Inboxes">Inboxes</span></h3>
<ul>
<li><strong>control</strong> : Shutdown signalling, and signalling to be fanned out.</li>
<li><strong>_control</strong> : Internal inbox for receiving from the child source component (if it exists)</li>
<li><strong>configuration</strong> : addsink(...) and removesink(...) request messages</li>
<li><strong>inbox</strong> : Data items to be fanned out.</li>
<li><strong>_inbox</strong> : Internal inbox for receiving from the child source component (if it exists)</li>
</ul>
<h3 id="outboxes-1"><span id="symbol-PlugSplitter.Outboxes">Outboxes</span></h3>
<ul>
<li><strong>outbox</strong> : Data items received on 'inbox' inbox.</li>
<li><strong>signal</strong> : Shutdown signalling, and data items received on 'control' inbox.</li>
</ul>
<h3 id="methods-defined-here-1">Methods defined here</h3>
<div class="container">
<div class="boxright">
<p><strong>Warning!</strong></p>
<p>You should be using the inbox/outbox interface, not these methods (except construction). This documentation is designed as a roadmap as to their functionalilty for maintainers and new component developers.</p>
</div>
</div>
<h4 id="init__self-sourcecomponent"><span id="symbol-PlugSplitter.__init__">__init__(self[, sourceComponent])</span></h4>
<p>x.__init__(...) initializes x; see x.__class__.__doc__ for signature</p>
<h4 id="addsinkself-sink-sinkinbox-sinkcontrol"><span id="symbol-PlugSplitter._addSink">_addSink(self, sink[, sinkinbox][, sinkcontrol])</span></h4>
<p>Add a new destination for data.</p>
<p>Specify target component (sink), and target inbox (sinkinbox) and/or target shutdown signalling inbox (sinkcontrol).</p>
<h4 id="delsinkself-sink-sinkinbox-sinkcontrol"><span id="symbol-PlugSplitter._delSink">_delSink(self, sink[, sinkinbox][, sinkcontrol])</span></h4>
<p>Remove a destination for data.</p>
<p>Specify target component (sink), and target inbox (sinkinbox) and/or target shutdown signalling inbox (sinkcontrol).</p>
<h4 id="childrendoneself-1"><span id="symbol-PlugSplitter.childrenDone">childrenDone(self)</span></h4>
<p>Unplugs any children that have terminated, and returns true if there are no running child components left (ie. their microproceses have finished)</p>
<h4 id="mainself-1"><span id="symbol-PlugSplitter.main">main(self)</span></h4>
<p>Main loop.</p>
<section>

</section>
<h1 id="kamaelia.util.splitter.splitter"><a href="/Components/pydoc/Kamaelia.html" class="reference">Kamaelia</a>.<a href="/Components/pydoc/Kamaelia.Util.html" class="reference">Util</a>.<a href="/Components/pydoc/Kamaelia.Util.Splitter.html" class="reference">Splitter</a>.<a href="/Components/pydoc/Kamaelia.Util.Splitter.Splitter.html" class="reference">Splitter</a></h1>
<h2 id="symbol-Splitter">class Splitter(<a href="/Docs/Axon/Axon.AdaptiveCommsComponent.AdaptiveCommsComponent.html" class="reference">Axon.AdaptiveCommsComponent.AdaptiveCommsComponent</a>)</h2>
<p>Splitter() -&gt; new Splitter component.</p>
<p>Splits incoming data out to multiple destinations. Send addsink(...) and removesink(...) messages to the 'configuration' inbox to add and remove destinations.</p>
<h3 id="inboxes-2"><span id="symbol-Splitter.Inboxes">Inboxes</span></h3>
<ul>
<li><strong>control</strong> : NOT USED</li>
<li><strong>configuration</strong> : addsink(...) and removesink(...) request messages</li>
<li><strong>inbox</strong> : Source of data items</li>
</ul>
<h3 id="outboxes-2"><span id="symbol-Splitter.Outboxes">Outboxes</span></h3>
<ul>
<li><strong>outbox</strong> : NOT USED</li>
<li><strong>signal</strong> : NOT USED</li>
</ul>
<h3 id="methods-defined-here-2">Methods defined here</h3>
<div class="container">
<div class="boxright">
<p><strong>Warning!</strong></p>
<p>You should be using the inbox/outbox interface, not these methods (except construction). This documentation is designed as a roadmap as to their functionalilty for maintainers and new component developers.</p>
</div>
</div>
<h4 id="init__self"><span id="symbol-Splitter.__init__">__init__(self)</span></h4>
<p>x.__init__(...) initializes x; see x.__class__.__doc__ for signature</p>
<h4 id="createsinkself-sink-sinkbox-passthrough"><span id="symbol-Splitter.createsink">createsink(self, sink[, sinkbox][, passthrough])</span></h4>
<p>Set up a new destination for data.</p>
<p>Creates an outbox, links it to the target (component,inbox) and records it in self.outlist.</p>
<h4 id="deletesinkself-oldsink"><span id="symbol-Splitter.deletesink">deletesink(self, oldsink)</span></h4>
<p>Removes the specified (component, inbox) as a destination for data where (component, inbox) = (oldsink.sink, oldsink.sinkbox).</p>
<p>Unlinks the target, destroys the corresponding outbox, and removes the corresponding record from self.outlist.</p>
<h4 id="mainbodyself"><span id="symbol-Splitter.mainBody">mainBody(self)</span></h4>
<p>Main loop body.</p>
<section>

</section>
</section>
</div>
<h1 id="feedback">Feedback</h1>
<p>Got a problem with the documentation? Something unclear that could be clearer? Want to help improve it? Constructive criticism is very welcome - especially if you can suggest a better rewording!</p>
<p>Please leave you feedback <a href="../../../cgi-bin/blog/blog.cgi?rm=viewpost&amp;nodeid=1142023701" class="reference">here</a> in reply to the documentation thread in the Kamaelia blog.</p>
<p><em>-- Automatic documentation generator, 05 Jun 2009 at 03:01:38 UTC/GMT</em></p>

</div> <!-- end section -->
</div> <!-- end page container -->

<div class="banner">
<a href="https://www.bbc.co.uk/rd"><img src="/site-resources/BBCRD_Logo.jpg"></a>
<P id="mini">  Kamaelia is an open source project originated from and guided
by <a href="https://www.bbc.co.uk/rd">BBC Research.</a> For more information
browse the site or get in contact.
<br>This is an ongoing community based development site.  As a result the
contents of this page is the opinions of the contributors of the pages
involved not the organisations involved.  Specificially, this page may
contain personal views which are not the views of the BBC.

<br>(C) Copyright 2004-2024 Kamaelia Contributors, including the British
Broadcasting Corporation, All Rights Reserved.
</div>
</body>
</html>
