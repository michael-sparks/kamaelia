<html>
<head>
<title> index </title>
<link rel=stylesheet type="text/css" href="/site-resources/base.css">
<link rel=stylesheet type="text/css" href="/site-resources/pandoc.css">
</head>
<body>
<div class="banner">
<P> <a href="/Home.html">Home</a> | 
    <a href="/About.html">About</a> | 
    <a href="/RecentChanges.html">Recent Changes</a> | 
    <a href="/Documentation.html">Documentation</a> |
    <a href="/Community.html">Community</a>
</div>
<div class="pagecontainer">
<div class="pagesection">
<div id="pagenote">
<p>March 2024 - This site, and Kamaelia are <a href="https://github.com/sparkslabs/kamaelia/issues/15">being updated</a>. There is significant work needed, and <a href="https://github.com/sparkslabs/kamaelia/pulls">PRs</a> are welcome.
</div>
<h1 id="inheritable-default-values">Inheritable Default Values</h1>
<div data-align="right">
<p><strong>Making systemic specialisation more
declarative</strong><br />
</p>
</div>
<p>This feature was introduced in Axon 1.6.0 (Kamaelia 0.6.0)<br />
<br />
The idea behind this is to allow a more compact, declarative way of
defining more complex Kamaelia systems. It stemmed initially from an
observation that two of us wanted to do this:<br />
<br />
</p>
<blockquote>
<pre><code>def ReusableSocketAddrServer(port=100,
                       protocol=EchoProtocol):
    return ServerCore(protocol=protocol,
                      port=port,
                      socketOptions=(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1))</code></pre>
</blockquote>
<p><br />
Specifically we noticed that we were creating a fair number of factory
functions which only really differed based on on value. The problem we
have here is that this is relatively fragile. Specifically, what happens
if ServerCore adds in extra arguments - do we also update
ReusableSocketAddrServer ? What if we don't, does someone else come
along and duplicate our code in order to support those extra arguments?
OK, well we can handle this in python if we use the **argd syntax. If we
do that, we can do that this way:<br />
</p>
<blockquote>
<pre><code>def ReusableSocketAddr(**argd):
    argd_local = dict(argd)
    argd_local[&quot;socketOptions&quot;] = (socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    return ServerCore(**argd_local)</code></pre>
</blockquote>
<p>Whilst that's maybe more reflective of what we wanted to do, it now
looks rather obscured. We then realised that there is a useful side
effect of python namespaces that we can take advantage of, which is
this:<br />
</p>
<p>self.attribute first of all looks inside the object self. If this is
not found...</p>
<p>self.attribute looks inside self.__class__ . If that's not found,</p>
<p>self.attribute looks inside the parents of self.__class__ all the way
up.</p>
<ul>
<li>This is kinda necessary to make (self.method) work, so it can be
relied upon.</li>
</ul>
<p>This means that if we change the base component class to do
this:<br />
</p>
<blockquote>
<pre><code>def __init__(self, **argd):
     self.__dict__.update(argd)</code></pre>
</blockquote>
<p>Then we can do this:<br />
</p>
<blockquote>
<pre><code>class ReusableSocketAttrServer(ServerCore):
    socketOptions=(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)  </code></pre>
</blockquote>
<p>This has a number of advantages over the factory method:<br />
</p>
<ul>
<li>First and foremost it makes it very clear that this is just a
ServerCore that happens to have different socketOptions.</li>
<li>Secondly it means that if the parent component (ServerCore) adds
extra arguments into the initialiser, we'll pick those up
automagically.</li>
<li>Thirdly, it encourages us to provide more things into the class
namespace, which actually assists with testing, but also makes the
system more flexible.</li>
</ul>
<p>For example, suppose the component we're using creates components as
a part of it's operation, and we want to add tracing to these. Normally
that code would default to looking like this:<br />
<br />
</p>
<blockquote>
<pre><code>from import Kamaelia.Internet.TCPServer import TCPServer

class ServerCore(...):
...

    def initialiseComponent(self):
...
            myPLS = TCPServer(listenport=self.listenport)</code></pre>
<p><strong>Hypothetical File:</strong> ExamplePatch.py<br />
</p>
</blockquote>
<p><br />
Replacing TCPServer here with our TracedTCPServer would have to look
like this:<br />
<br />
</p>
<blockquote>
<pre><code>from Hypothetical import TracedTCPServer
import ExamplePatch
ExamplePatch.TCPServer = TracedTCPServer</code></pre>
<p><strong>Hypothetical File:</strong> ExamplePatchUser.py<br />
</p>
</blockquote>
<p>The downside of this as well is that this is not particularly
targetted, and leads to the situation where it would be more natural to
create a copy of the code for traced versions. This misses one of the
handy features of what inheritance gives us, which is controlled
duplication of functionality with little twists of functionality. By
comparison, with inheritable default values, we can do this
instead:<br />
<br />
</p>
<blockquote>
<pre><code>from import Kamaelia.Internet.TCPServer import TCPServer

class ServerCore(...):
    TCPS = TCPServer
    def initialiseComponent(self):
...
            TCPServer = self.TCPS
            myPLS = TCPServer(listenport=self.listenport)</code></pre>
<p><strong>Hypothetical File:</strong> ExamplePatch.py<br />
</p>
</blockquote>
<p>However, when someone wants to create a traced version they can be
far more to the point. Suppose they have code that looks like
this:<br />
ServerCore(port = 1500, protocol=WhizzyProto1).run()<br />
<br />
They can change it over to use the hypothetical TracedTCPServer like
this:<br />
</p>
<blockquote>
<pre><code>from Hypothetical import TracedTCPServer

ServerCore(port = 1500, protocol=WhizzyProto1, TCPS=TracedTCPServer).run()</code></pre>
<p><strong>Hypothetical File:</strong> ExamplePatchUser.py</p>
</blockquote>
<p><br />
Not only that, but if they wanted to define this as a common thing they
wanted to do, they could do this:<br />
</p>
<blockquote>
<pre><code>class TracedServerCore(ServerCore):
     TCPS = TracedTCPServer</code></pre>
</blockquote>
<p>Which would then get used:<br />
</p>
<blockquote>
<pre><code>TracedServerCore(port = 1500, protocol=WhizzyProto1).run()</code></pre>
</blockquote>
<p>Whilst this seems theoretical, it was bandied about as a possible
idea for nearly a year until it suddenly became extremely useful -
specifically in the [greylisting code](/KamaeliaGrey.html to allow it to
use inactivity timers on connected sockets, as well as configuration of
protocol handlers in a declarative manner:<br />
</p>
<blockquote>
<pre><code>class GreylistServer(ServerCore):
    logfile = config[&quot;greylist_log&quot;]
    debuglogfile = config[&quot;greylist_debuglog&quot;]
    socketOptions=(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    port = config[&quot;port&quot;]
    class TCPS(TCPServer):
        CSA = NoActivityTimeout(ConnectedSocketAdeapter, timeout=config[&quot;inactivity_timeout&quot;], debug=False)
    class protocol(GreyListingPolicy):
        servername = config[&quot;servername&quot;]
        serverid = config[&quot;serverid&quot;]
        smtp_ip = config[&quot;smtp_ip&quot;]
        smtp_port = config[&quot;smtp_port&quot;]
        allowed_senders = config[&quot;allowed_senders&quot;]
        allowed_sender_nets = config[&quot;allowed_sender_nets&quot;] # Yes, only class C network style
        allowed_domains = config[&quot;allowed_domains&quot;]
        whitelisted_triples = config[&quot;whitelisted_triples&quot;]
        whitelisted_nonstandard_triples = config[&quot;whitelisted_nonstandard_triples&quot;]</code></pre>
</blockquote>
<p>Since then the idiom has been found to be useful in other
scenarios.<br />
<br />
It's also worth noticing that this also means that the ServerCore code
could be repurposed to work with servers that act in a similar way to
TCPServer. For example, a hypothetical ConnectionBasedUDPListener, could
be created which operated in a similar manner to TCPServer, and then
reused as follows:<br />
</p>
<blockquote>
<pre><code>class UDPServerCore(ServerCore):
     TCPS = ConnectionBasedUDPListener</code></pre>
</blockquote>
<p>Thereby making it as simple to create connection oriented UDP servers
as it would be to create TCPServers. The only difference between the two
being lack of guarantee of ordering or delivery.<br />
</p>
<h2 id="downsides">Downsides?</h2>
<p>The clear downside of this is that the signature of your component's
generally initialiser becomes this:<br />
</p>
<blockquote>
<pre><code>def __init__(self, **argd):
 ...</code></pre>
</blockquote>
<p>This in turn puts a greater onus on you as a component writer to
document the arguments to your component in a clearer manner.<br />
<br />
</p>
<h2 id="but-why">But WHY???</h2>
<p>This is an implicit thing. <strong>In Kamaelia when syntactic sugar
gets added</strong> (and that's precisely what this is), <strong>one of
the most common aims is to aim to move towards a declarative reusable
syntax.</strong> After all, if you consider that the starting point was
this:<br />
</p>
<blockquote>
<pre><code>def ReusableSocketAddrServer(port=100,
                       protocol=EchoProtocol):
    return ServerCore(protocol=protocol,
                      port=port,
                      socketOptions=(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1))</code></pre>
</blockquote>
<p>You're actually starting off with something very fragile, especially
considering that if ServerCore changes it's configuration, you have to
change this factory function as well.<br />
<br />
Secondly, the next approach for dealing with changing __init__ialiser
arguments is to use **argd, you then end up with something which is a
bit perl-ish in structure, and obfuscates what's really going on:<br />
</p>
<blockquote>
<pre><code>def ReusableSocketAddr(**argd):
    argd_local = dict(argd)
    argd_local[&quot;socketOptions&quot;] = (socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    return ServerCore(**argd_local)</code></pre>
</blockquote>
<p>However, by switching over to an inheritable default value approach
you gain something which is declarative, picks up new default values
from the base class cleanly and makes it much clearer that actually this
returns objects of this type, just preconfigured in a particular
way:<br />
</p>
<blockquote>
<pre><code>class ReusableSocketAttrServer(ServerCore):
    socketOptions=(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)  </code></pre>
</blockquote>
<p>So, by aiming for a syntactic sugar that's declarative in nature,
we're hopefully making the intent in the system clearer.<br />
</p>
<h2 id="summary">Summary</h2>
<p><br />
If you want to provide default values for parameters for your
components, and please do, providing them in the form of inheritable
default values will make your components more useful to others. You
don't have to do this, and if you find it odd, simply don't do this.
However if you do, it would be appreciated by the users of your
code.<br />
<br />
</p>

</div> <!-- end section -->
</div> <!-- end page container -->

<div class="banner">
<a href="https://www.bbc.co.uk/rd"><img src="/site-resources/BBCRD_Logo.jpg"></a>
<P id="mini">  Kamaelia is an open source project originated from and guided
by <a href="https://www.bbc.co.uk/rd">BBC Research.</a> For more information
browse the site or get in contact.
<br>This is an ongoing community based development site.  As a result the
contents of this page is the opinions of the contributors of the pages
involved not the organisations involved.  Specificially, this page may
contain personal views which are not the views of the BBC.

<br>(C) Copyright 2004-2024 Kamaelia Contributors, including the British
Broadcasting Corporation, All Rights Reserved.
</div>
</body>
</html>
