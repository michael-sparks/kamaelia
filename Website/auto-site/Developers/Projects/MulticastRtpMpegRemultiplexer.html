<html>
<head>
<title> index </title>
<link rel=stylesheet type="text/css" href="/site-resources/base.css">
<link rel=stylesheet type="text/css" href="/site-resources/pandoc.css">
</head>
<body>
<div class="banner">
<P> <a href="/Home.html">Home</a> | 
    <a href="/About.html">About</a> | 
    <a href="/RecentChanges.html">Recent Changes</a> | 
    <a href="/Documentation.html">Documentation</a> |
    <a href="/Community.html">Community</a>
</div>
<div class="pagecontainer">
<div class="pagesection">
<div id="pagenote">
<p>March 2024 - This site, and Kamaelia are <a href="https://github.com/sparkslabs/kamaelia/issues/15">being updated</a>. There is significant work needed, and <a href="https://github.com/sparkslabs/kamaelia/pulls">PRs</a> are welcome.
</div>
<h2 data-align="left"
id="project-task-page-multicast-rtp-mpeg-remultiplexer">Project Task
Page: Multicast RTP MPEG Remultiplexer</h2>
<div class="boxright">
<p><strong>Status:</strong> Blocked <em>- Performance bottlenecks - code
can't run fast enough</em><br />
<strong>Current Developers:</strong> <em>Matt</em><br />
<strong>Current "inflight" dev location:</strong>
<em>/Sketches/MH/RTP/</em><br />
<strong>Start Date:</strong> ??<br />
<strong>Major Milestone date:</strong> n/a<br />
<strong>Expected End Date:</strong> 22nd December 2006<br />
<strong>End Date:</strong> <em>tbd</em><br />
<strong>Date this page last updated:</strong> <em>27th November
2006</em><br />
<strong>Estimated effort so far:</strong> <em>9 days</em><br />
</p>
</div>
<h2 id="description">Description</h2>
<p>A tool to mix MPEG transport streams received over multicast in RTP
format; and rebroadcast as a new multicast RTP stream.<br />
<br />
Internal work on developing live multicast streaming services needs a
way to take data from one stream and mix it into another. The streams
are multicast RTP packets containing MPEG Transport Stream data. The
tool, when deployed should be able to run 24/7, combining a subset of
data from 2 or more streams to generate a new one. This would be used,
for example, to mix existing EPG data into an existing stream containing
audio and video.<br />
<br />
Benefits:<br />
</p>
<ul>
<li>RTP packetising/depacketising components</li>
<li>Possibly more MPEG components</li>
<li>Seleector and multicast component optimisations<br />
</li>
</ul>
<p><br />
</p>
<h2 id="inputs">Inputs</h2>
<p>Task Sponsor: BB (BBC internal)<br />
Task Owner: Matt (MH)<br />
Developers:<br />
</p>
<ul>
<li>Matt</li>
</ul>
<p>User</p>
<ul>
<li>BB</li>
</ul>
<p>Interested Third Parties<br />
</p>
<ul>
<li>RB (BBC internal)</li>
</ul>
<p>Requirements (non exhaustive):<br />
</p>
<p>Receive multicast RTP containing MPEG Transport Stream containing
H264 @ ~1Mbit/s (MUST)</p>
<p>Simulataneously receive a 2nd multicast RTP containing MPEG Transport
Stream containing EIT data and MPEG2 video @ ~5Mbit/s (MUST)</p>
<p>Combine (demultiplex and remultiplex) EIT data from 2nd stream with
video from the 1st to form a new stream (MUST)<br />
</p>
<p>Transmit the new stream as multicast RTP (MUST)</p>
<p>Adjust stream timestamps (MPEG Transport Stream level, and possibly
MPEG Program Elementary Stream level) if needed (WOULD LIKE)</p>
<ul>
<li>uncertain of this until able to test with various clients</li>
<li>Derived from discussions with RB</li>
</ul>
<p>Relevant Influencing factors:<br />
</p>
<ul>
<li><em>eg release of a tool doing the same sort of thing that renders
this non-relevant</em></li>
<li><em>people joining/leaving project</em></li>
<li><em>change of sponsorship</em></li>
<li><em>growth in users/thirdparties</em></li>
<li><em>tool dependency suitablility</em></li>
<li><em>unexpected complications</em></li>
<li>*speed of available hardware / speed of Axon/Kamaelia<br />

<ul>
<li></li>
</ul></li>
</ul>
<h2 id="outputs">Outputs</h2>
<h3 id="expected">Expected</h3>
<p>Components to parse and create RTP packets</p>
<p>Command line tool, as described</p>
<ul>
<li>/Sketches/MH/RTP/RTPMux.py</li>
</ul>
<p>Webpages describing:</p>
<ul>
<li>architecture</li>
<li>usage<br />
</li>
</ul>
<h3 id="actual">Actual</h3>
<p>Code</p>
<p>RTP handling</p>
<ul>
<li>/Sketches/MH/RTP/RTPFramer.py</li>
<li>/Sketches/MH/RTP/RTPDeFramer.py</li>
</ul>
<p>Internet components (uprades/modifications)<br />
</p>
<ul>
<li>/Sketches/MH/RTP/Multicast_transceiver.py</li>
<li>/Sketches/MH/RTP/Selector.py</li>
<li>/Sketches/MH/RTP/ConnectedSocketAdaptor.py</li>
</ul>
<p>SDP handling</p>
<ul>
<li>/Sketches/MH/RTP/SDP.py<br />
</li>
</ul>
<p>DVB/MPEG Transport stream processing</p>
<ul>
<li>/Sketches/MH/DVB_Remux/ExtractPCR.py</li>
</ul>
<p>case-insensitivity problem fixed for /trunk/</p>
<p>...removing filename clash problems for case insensitive filesystems
like that on win32/osx</p>
<ul>
<li>Code/Python/Kamaelia/Kamaelia/Util/passThrough.py<br />
</li>
</ul>
<h3
id="realistic-possibilities-arising-as-a-result-of-activity-on-this-task">Realistic
possibilities arising as a result of activity on this task</h3>
<p>New/modified components for mainline codebase (RTP, DVB)</p>
<ul>
<li>review and merge some or all of the above components</li>
</ul>
<h2 id="related-tasks">Related Tasks</h2>
<h3 id="tasks-that-directly-enable-this-task-dependencies">Tasks that
directly enable this task (dependencies)</h3>
<ul>
<li><a href="/Developers/Projects/DVBTools%20">DVB Tools</a></li>
<li>TCP Subsystem<br />
</li>
</ul>
<h3 id="subtasks">Subtasks</h3>
<p>Improved throughput of multicast component and Selector in
general</p>
<ul>
<li>rewrite multicast_transceiver to use Selector</li>
<li>modified Selector to be instantly woken if a component requests to
add a reader/writer/exceptional</li>
</ul>
<p>Develop code<br />
</p>
<h2 id="task-log">Task Log</h2>
<ul>
<li>05 October 2006 - Matt : Added developer Matt. <strong>Task status
changed</strong> to Running<br />
</li>
<li>11 October 2006 - Matt : development to date: Time spent 5 days.
<strong>Task status changed</strong> to stasis<br />
</li>
<li>12 November 2006 - Matt : Code modifications: Time spent 1/2
day.</li>
<li>20 November 2006 - Matt : <strong>Task status changed</strong> to
blocked - requested, and awaiting, hardware &amp; info on streams from
BB</li>
<li>06 December 2006 - Matt : <strong>Task status changed</strong> to
running - got new hardware</li>
<li>11 Decemeber 2006 - Matt : Built initial then 'proper' SDP parser.
Time spent 2 days</li>
<li>14 December 2006 - Matt : Code doesn't run fast enough. Investigated
options and determined a possible solution involving modifying Axon
(should be a separate task). <strong>Task status changed</strong> to
blocked. Time spent 1.5 days<br />
</li>
</ul>
<h2 id="discussion">Discussion</h2>
<h3 id="stream-synchronisation-timestamps-may-need-regenerating">Stream
Synchronisation Timestamps may need regenerating</h3>
<p>Need to determine, experimentally, if timestamp resynchronisation
algorithms will be neededIf resynchronisation algorithms are needed.
Technically remultiplexing severely jitters the timestamps on the
transport stream packets.<br />
</p>
<ul>
<li>For a traditional Set-top-box style receiver device, these
timestamps are used to regenerate the precise bitrate of the original
data stream. They do this for the purposes of generating their own
timing clocks for video and audio output. (RB)<br />
</li>
<li>Computer based video players are probably less likely to use this as
they don't have access or control over very accurate clocks, or the
precise timing of their local sound and video subsystems. Instead they
are more likely to simply buffer data and play it at their own rate.
(Matt)</li>
<li>This may be a substantial piece of work, as MPEG PES packets will
need decoding from transport stream packets and an algorithm would have
to be identified or devised to calculate the new timestamps. This may be
problematic as the original streams appear to be highly variable
bitrate.<br />
</li>
</ul>
<h3 id="cpu-load-higher-than-anticipated">CPU load higher than
anticipated</h3>
<p>CPU load is higher than anticipated - handling a single 1-2Mbit/s
stream takes 50%+ CPU usage on the Mac Mini currently being used for
testing. A faster "Core Duo" Mac Mini has been tried, but the system
struggles to keep up with the 4Mbps MPEG2 stream (ie. usage teeters
close to 90%/100%).<br />
<br />
<strong>Multicast I/O improvements</strong><br />
<br />
Selector component has been improved (local copy in the working dir) to
increase responsiveness. Specifically, instead of requests to select on
file handles queueing up at its inbox until the current select() call
timeout fires; a separate filehandle is used to wake it immediately if
there are pending requests.<br />
<br />
The Multicast components have been optimised (local copy in the working
dir) to sleep when inactive, using the Selector component to wake
them.<br />
<br />
<strong>Threaded component bottlenecks</strong><br />
<br />
I've also tried writing<br />
<br />
Why? Interactions between a thread and the main thread are
bottlenecked:<br />
</p>
<ul>
<li>the thread (doing the select() calls in the case of the Selector)
passes addOutbox, deleteOutbox, link and unlink operations to the main
thread and waits for it to do them. It does this (and has to wait) to
ensure thread safety. Since Selector makes and removes the boxes and
linkages used every time it handles a request to wait on a
socket/file.</li>
<li>sending and receiving messages is done via a 'proxy' microprocess
running in the main thread. In the case of components like the Selector,
this extra overhead is probably equal to the time being spent in the
thread.<br />
</li>
</ul>
<p>Each component is taking between 10% and 20% CPU. Moving the Selector
or Multicast components themselves into separate threads doesn't reduce
the amount of CPU being spent in the main thread. The Mac Mini could
probably cope if it were possible to spread some of the workload across
the 2nd CPU without incurring a penalty in the main thread.<br />
<br />
<strong>Proposal: Axon modifications</strong><br />
<br />
I believe there may be mileage in experimenting with modifying Axon such
that threads can perform all tasks themselves, using (hopefully fine
grained) locking to ensure thread safety. This would eliminate the need
for threaded components to have a microprocess running in main thread
handling all its requests. This would substantially reduce the overhead
incurred when making a component threaded. It would potentially also
have the benefit that two components running in threads independant of
the main thread would not be bottlenecked by the needing the main thread
to handle message passing on their behalf.<br />
<br />
This would probably qualify as a separate project task, lasting a few
weeks.<br />
<br />
<strong>Other routes to try first</strong><br />
<br />
Michael suggests that such a radical approach may well not be necessary.
Instead the following perhaps should be tried first:<br />
</p>
<ul>
<li>converting intensive data manipulation tasks (such as RTP demuxing
and remuxing) to pyrex code (ie. converting it partially to C). The MPEG
demuxer is already pyrex'ed.</li>
<li>Grouping data into larger chunks for message passing between
components - reducing the message passing overheads per mpeg/rtp
packet</li>
</ul>
<p><br />
</p>

</div> <!-- end section -->
</div> <!-- end page container -->

<div class="banner">
<a href="https://www.bbc.co.uk/rd"><img src="/site-resources/BBCRD_Logo.jpg"></a>
<P id="mini">  Kamaelia is an open source project originated from and guided
by <a href="https://www.bbc.co.uk/rd">BBC Research.</a> For more information
browse the site or get in contact.
<br>This is an ongoing community based development site.  As a result the
contents of this page is the opinions of the contributors of the pages
involved not the organisations involved.  Specificially, this page may
contain personal views which are not the views of the BBC.

<br>(C) Copyright 2004-2024 Kamaelia Contributors, including the British
Broadcasting Corporation, All Rights Reserved.
</div>
</body>
</html>
