<html>
<head>
<title> index </title>
<link rel=stylesheet type="text/css" href="/site-resources/base.css">
<link rel=stylesheet type="text/css" href="/site-resources/pandoc.css">
</head>
<body>
<div class="banner">
<P> <a href="/Home.html">Home</a> | <a href="/About.html">About</a> | <a href="/Developers.html">Developers</a>
</div>
<div class="pagecontainer">
<div class="pagesection">
<div id="pagenote">
<p>Feb 2024 - This site, and Kamaelia are <a href="https://github.com/sparkslabs/kamaelia/issues/15">being updated</a>. There is significant work needed, and <a href="https://github.com/sparkslabs/kamaelia/pulls">PRs</a> are welcome.
</div>
<h2 id="project-task-page-multicast-proxy-tools">Project Task Page: Multicast Proxy Tools</h2>
<h2 id="description">Description</h2>
<div class="boxright">
<p><strong>Status:</strong> Stasis<br />
<strong>Current active developer:</strong><br />
<strong>Current dev locations:</strong> /Sketches/MPS/Systems/MulticastProxying<br />
<strong>Start Date:</strong> 9 June 2006<br />
<strong>Expected date:</strong> n/a<br />
<strong>end date:</strong> n/a<br />
<strong>This page last updated:</strong> 27th Nov 2006<br />
<strong>Estimated effort so far:</strong> 1/2 man day<br />
</p>
</div>
<p>This task aims to produce tools to make it simpler to join multicast islands together - in essence tools for proxying multicast over non-multicast enabled networks.</p>
<p>A direct end result of this is that it would enable someone to take a multicast stream, send it to a proxying hub, allow clients to connect to this multicast hub, and those clients would then remulticast that stream within a local (eg corporate intranet) network for local availability.<br />
This task was created because it was deemed to be hopefully useful to a particular internal client at the BBC.<br />
Some specific benefits of working on this include:<br />
<br />
</p>
<h3 id="inputs">Inputs</h3>
<p>Task Sponsor: (for BB)<br />
Task Owner: Michael (mps)<br />
Developers:<br />
</p>
<ul>
<li>Michael</li>
</ul>
<p>Users:<br />
</p>
<ul>
<li>BB (potential)<br />
</li>
</ul>
<p>Interested Third Parties<br />
</p>
<ul>
<li>na</li>
</ul>
<p>Requirements:<br />
</p>
<blockquote>
<p>The expected scenario for these components is that there are situations as follows:<br />
</p>
</blockquote>
<ul>
<li>A single source which is desirable to multicast to a large population (mps)</li>
<li>A large population has many sources in which it wishes to multicast to itself (mps)</li>
<li>The population consists of many disaparate multicast islands which need joining (mps)</li>
<li>They desire having a central hub, to join islands together (mps)</li>
<li>They wish to join multiple islands together directly and in a distibuted fashion and route between islands. (mps)</li>
</ul>
<blockquote>
<p>This is a non-exhaustive set of input states.<br />
</p>
</blockquote>
<h2 id="outputs">Outputs</h2>
<h3 id="expected"><strong>Expected</strong></h3>
<ul>
<li>Tools to allow multicast data and data sources to be proxied between locations effectively. The tools can be assumed at this level to not have to deal with any automated mesh set up or autodiscovery - merely to allow such higher level systems to be created.</li>
</ul>
<h3 id="actual"><strong>Actual</strong></h3>
<p><strong>Code Produced:</strong><br />
These tools already exist in the subversion repository in /Sketches/MPS/Systems/MulticastProxying. Files in that directory and purpose:<br />
</p>
<p><strong><em>config.py</em></strong><br />
Defines the following config options<br />
</p>
<blockquote>
<p>mcast_group, mcast_port - The multicast group/port to be proxied<br />
mcast_tcp_splitter_ip, mcast_tcp_splitter_port - IP/port of a simple TCP Splitter that serves the contents of a given multicast group to people who connect<br />
tcp_tcp_splitter_ip, tcp_tcp_splitter_port - IP/port of a TCP Splitter that accepts a data source from a single TCP client<br />
tcp_splitter_client_ip, tcp_splitter_client_port - IP/port of the TCP Splitter where clients can connect to recieve that data source</p>
</blockquote>
<p><strong><em>MulticastTCPClientRelay.py</em></strong></p>
<ul>
<li>This is a simple proxy to relay multicast data from a given multicast group and port to a TCP server which may choose to do something with the data (eg split and forward).<br />
</li>
</ul>
<p><strong><em>MulticastTCPRelay.py</em></strong></p>
<ul>
<li>This is a simple proxy to relay multicast data from a given multicast group and port as a TCP Service on a given port. It's worth noting that this is one way - any data from the TCP connection is discarded.<br />
</li>
</ul>
<p><strong><em>SplittingServer.py</em></strong></p>
<ul>
<li>Splitting server. This expects a single inbound connection on one port and spits it out to all recipients who connect on another port. This can be<br />
used as an alternate server for the TCPRelayMulticast to connect to, and it would expect to be fed using MulticastTCPClientRelay.<br />
</li>
</ul>
<p><strong><em>TCPRelayMulticast.py</em></strong></p>
<ul>
<li>A TCP Client that connects to the splitting server, and takes any data it receives a resends it as a multicast stream</li>
</ul>
<h3 id="realistic-possibilities-arising-as-a-result-of-activity-on-this-task">****Realistic possibilities arising as a result of activity on this task ****</h3>
<p>The creation of tools that allow for automated mesh setup building on this allow for the realistic possibility of merging application layer multicast with IP level multicast.<br />
<strong>Tasks that could benefit from or build on this work:</strong><br />
</p>
<ul>
<li>Whiteboard - specifically P2P Events Backplane (An extraction exercise)<br />
</li>
</ul>
<h2 id="related-tasks">Related Tasks</h2>
<h3 id="tasks-that-directly-enable-this-task">Tasks that directly enable this task</h3>
<ul>
<li>Multicast Transciever</li>
<li>Internet Subsystem</li>
</ul>
<h3 id="sub-tasks">Sub tasks</h3>
<ul>
<li>Coding each of the types of server, client and relay. (each of these is too small to be worth while)<br />
</li>
</ul>
<h3 id="task-log">Task Log</h3>
<ul>
<li>Initial version of the code developed, uploaded, and feedback sought from potential sponsor. This page created and project placed into <strong>stasis.</strong> (ie can be reactivated at any later point in time).<br />
<br />
Time working on code ~ 1/2 day<br />
Time working on this page ~ 1/2 hour<br />
Entry made: Michael, 27th November 2006<br />
</li>
</ul>
<h2 id="discussion">Discussion</h2>
<p>Potential future implementation approaches could see<br />
</p>
<ul>
<li>Automated mesh creation.</li>
<li>Transport over other mechanisms - such as UDP, STCP, etc</li>
<li>Authentication before joining the mesh</li>
<li>Integration with the implicit P2P events backplane in the Whiteboard</li>
</ul>
<p>-- Michael Sparks, 27th November 2006<br />
</p>

</div> <!-- end section -->
</div> <!-- end page container -->

<div class="banner">
<a href="https://www.bbc.co.uk/rd"><img src="/site-resources/BBCRD_Logo.jpg"></a>
<P id="mini">  Kamaelia is an open source project originated from and guided
by <a href="https://www.bbc.co.uk/rd">BBC Research.</a> For more information
browse the site or get in contact.
<br>This is an ongoing community based development site.  As a result the
contents of this page is the opinions of the contributors of the pages
involved not the organisations involved.  Specificially, this page may
contain personal views which are not the views of the BBC.

<br>(C) Copyright 2004-2024 Kamaelia Contributors, including the British
Broadcasting Corporation, All Rights Reserved.
</div>
</body>
</html>
