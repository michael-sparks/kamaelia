<html>
<head>
<title> index </title>
<link rel=stylesheet type="text/css" href="/site-resources/base.css">
<link rel=stylesheet type="text/css" href="/site-resources/pandoc.css">
</head>
<body>
<div class="banner">
<P> <a href="/Home.html">Home</a> | <a href="/About.html">About</a> | <a href="/Developers.html">Developers</a>
</div>
<div class="pagecontainer">
<div class="pagesection">
<div id="pagenote">
<p>Feb 2024 - This site, and Kamaelia are <a href="https://github.com/sparkslabs/kamaelia/issues/15">being updated</a>. There is significant work needed, and <a href="https://github.com/sparkslabs/kamaelia/pulls">PRs</a> are welcome.
</div>
<div class="container">
<section>
<h2 id="axon.stm"><a href="/Docs/Axon/Axon.html" class="reference">Axon</a>.<a href="/Docs/Axon/Axon.STM.html" class="reference">STM</a></h2>
</section>
<h1 id="stm">STM</h1>
<div class="container">
<ul>
<li><strong>class <a href="/Docs/Axon/Axon.STM.BusyRetry.html" class="reference">BusyRetry</a></strong></li>
<li><strong>class <a href="/Docs/Axon/Axon.STM.Collection.html" class="reference">Collection</a></strong></li>
<li><strong>class <a href="/Docs/Axon/Axon.STM.ConcurrentUpdate.html" class="reference">ConcurrentUpdate</a></strong></li>
<li><strong>class <a href="/Docs/Axon/Axon.STM.Store.html" class="reference">Store</a></strong></li>
<li><strong>class <a href="/Docs/Axon/Axon.STM.Value.html" class="reference">Value</a></strong></li>
</ul>
</div>
<ul>
<li><a href="#52" class="reference">What IS it?</a></li>
<li><a href="#53" class="reference">Why is it useful?</a></li>
<li><a href="#54" class="reference">Using It</a>
<ul>
<li><a href="#55" class="reference">Accessing/Updating a single shared value in the store</a></li>
<li><a href="#56" class="reference">Accessing/Updating a collection of shared values in the store</a></li>
</ul></li>
<li><a href="#57" class="reference">What can (possibly) go wrong?</a></li>
</ul>
<section>
<p>Support for basic in-process software transactional memory.</p>
<h2 id="what-is-it-52"><span id="what-is-it">What IS it?</span> {#52}</h2>
<p>Software Transactional Memory (STM) is a technique for allowing multiple threads to share data in such a way that they know when something has gone wrong. It's been used in databases (just called transactions there really) for some time and is also very similar to version control. Indeed, you can think of STM as being like variable level version control.</p>
<h2 id="why-is-it-useful-53"><span id="why-is-it-useful">Why is it useful?</span> {#53}</h2>
<p>Why do you need it? Well, in normal code, Global variables are generally shunned because it can make your code a pain to work with and a pain to be certain if it works properly. Even with linear code, you can have 2 bits of code manipulating a structure in surprising ways - but the results are repeatable. Not-properly-managed-shared-data is to threaded systems as not-properly-managed-globals are to normal code. (This code is one way of helping manage shared data)</p>
<p>Well, with code where you have multiple threads active, having shared data is like an even nastier version of globals. Why? Well, when you have 2 (or more) running in parallel, the results of breakage can become hard to repeat as two pieces of code "race" to update values.</p>
<p>With STM you make it explicit what the values are you want to update, and only once you're happy with the updates do you publish them back to the shared storage. The neat thing is, if someone else changed things since you last looked, you get told (your commit fails), and you have to redo the work. This may sound like extra work (you have to be prepared to redo the work), but it's nicer than your code breaking :-)</p>
<p>The way you get that message is the .commit raises a ConcurrentUpdate exception.</p>
<p>Also, it's designed to work happily in code that requires non-blocking usage - which means you may also get a BusyRetry exception under load. If you do, you should as the exception suggests retry the action that you just tried. (With or without restarting the transaction)</p>
<p>Apologies if that sounds too noddy :)</p>
<h2 id="using-it-54"><span id="using-it">Using It</span> {#54}</h2>
<h3 id="accessingupdating-a-single-shared-value-in-the-store-55"><span id="accessing-updating-a-single-shared-value-in-the-store">Accessing/Updating a single shared value in the store</span> {#55}</h3>
<p>You can have many single vars in a store of course... If they're related though or updated as a group, see the next section:</p>
<pre class="literal-block"><code>from Axon.STM import Store

S = Store()
greeting = S.usevar(&quot;hello&quot;)
print repr(greeting.value)
greeting.set(&quot;Hello World&quot;)
greeting.commit()</code></pre>
<h3 id="accessingupdating-a-collection-of-shared-values-in-the-store-56"><span id="accessing-updating-a-collection-of-shared-values-in-the-store">Accessing/Updating a collection of shared values in the store</span> {#56}</h3>
<p>Likewise you can use as many collections of values from the store as you like:</p>
<pre class="literal-block"><code>from Axon.STM import Store

S = Store()
D = S.using(&quot;account_one&quot;, &quot;account_two&quot;, &quot;myaccount&quot;)
D[&quot;account_one&quot;].set(50)
D[&quot;account_two&quot;].set(100)
D.commit()
S.dump()

D = S.using(&quot;account_one&quot;, &quot;account_two&quot;, &quot;myaccount&quot;)
D[&quot;myaccount&quot;].set(D[&quot;account_one&quot;].value+D[&quot;account_two&quot;].value)
D[&quot;account_one&quot;].set(0)
D[&quot;account_two&quot;].set(0)
D.commit()
S.dump()</code></pre>
<h2 id="what-can-possibly-go-wrong-57"><span id="what-can-possibly-go-wrong">What can (possibly) go wrong?</span> {#57}</h2>
<p>You can have 2 people trying to update the same values at once. An example of this would be - suppose you have the following commands being executed by 2 threads with this mix of commands:</p>
<pre class="literal-block"><code>S = Store()
D = S.using(&quot;account_one&quot;, &quot;account_two&quot;, &quot;myaccount&quot;)
D[&quot;myaccount&quot;].set(0)
D[&quot;account_one&quot;].set(50)
D[&quot;account_two&quot;].set(100)
D.commit() # 1
S.dump()

D = S.using(&quot;account_one&quot;, &quot;account_two&quot;, &quot;myaccount&quot;)
D[&quot;myaccount&quot;].set(D[&quot;account_one&quot;].value+D[&quot;account_two&quot;].value)
E = S.using(&quot;account_one&quot;, &quot;myaccount&quot;)
E[&quot;myaccount&quot;].set(E[&quot;myaccount&quot;].value-100)
E[&quot;account_one&quot;].set(100)
E.commit() # 2
D[&quot;account_one&quot;].set(0)
D[&quot;account_two&quot;].set(0)
D.commit() # 3 - should fail
S.dump()</code></pre>
<p>You do actually want this to fail because you have concurrent updates. This will fail on the third commit, and fail by throwing a ConcurrentUpdate exception. If you get this, you should redo the transaction.</p>
<p>The other is where there's lots of updates happening at once. Rather than the code waiting until it acquires a lock, it is possible for either the .using, .usevar or .commit methods to fail with a BusyRetry exception. This means exactly what it says on the tin - the system was busy &amp; you need to retry. In this case you do not have to redo the transaction. This is hard to replicate except under load. The reason we do this however is because most Kamaelia components are implemented as generators, which makes blocking operation ( as a .acquire() rather than .acquire(0) would be) an expensive operation.</p>
</section>
<hr />
<section>
<h1 id="axon.stm.busyretry"><a href="/Docs/Axon/Axon.html" class="reference">Axon</a>.<a href="/Docs/Axon/Axon.STM.html" class="reference">STM</a>.<a href="/Docs/Axon/Axon.STM.BusyRetry.html" class="reference">BusyRetry</a></h1>
<h2 id="symbol-BusyRetry">class BusyRetry(Exception)</h2>
<section>

</section>
<section>

</section>
<h1 id="axon.stm.collection"><a href="/Docs/Axon/Axon.html" class="reference">Axon</a>.<a href="/Docs/Axon/Axon.STM.html" class="reference">STM</a>.<a href="/Docs/Axon/Axon.STM.Collection.html" class="reference">Collection</a></h1>
<h2 id="symbol-Collection">class Collection(dict)</h2>
<section>
<p>Collection() -&gt; new Collection dict</p>
<p>A dictionary which belongs to a thread-safe store</p>
<p>Again, you do not instantiate these yourself</p>
</section>
<h3 id="methods-defined-here">Methods defined here</h3>
<h4 id="commitself"><span id="symbol-Collection.commit">commit(self)</span></h4>
<p>Commit new versions of the collection's items to the store</p>
<h4 id="set_storeself-store"><span id="symbol-Collection.set_store">set_store(self, store)</span></h4>
<p>Set the store to associate the collection with</p>
<section>

</section>
<h1 id="axon.stm.concurrentupdate"><a href="/Docs/Axon/Axon.html" class="reference">Axon</a>.<a href="/Docs/Axon/Axon.STM.html" class="reference">STM</a>.<a href="/Docs/Axon/Axon.STM.ConcurrentUpdate.html" class="reference">ConcurrentUpdate</a></h1>
<h2 id="symbol-ConcurrentUpdate">class ConcurrentUpdate(Exception)</h2>
<section>

</section>
<section>

</section>
<h1 id="axon.stm.store"><a href="/Docs/Axon/Axon.html" class="reference">Axon</a>.<a href="/Docs/Axon/Axon.STM.html" class="reference">STM</a>.<a href="/Docs/Axon/Axon.STM.Store.html" class="reference">Store</a></h1>
<h2 id="symbol-Store">class Store(object)</h2>
<section>
<p>Store() -&gt; new Store object</p>
<p>A thread-safe versioning store for key-value pairs</p>
<p>You instantiate this as per the documentation for this module</p>
</section>
<h3 id="methods-defined-here-1">Methods defined here</h3>
<h4 id="can_updateself-key-value"><span id="symbol-Store.__can_update">__can_update(self, key, value)</span></h4>
<p>Returns true if a value can be safely updated. Potentially not thread-safe</p>
<h4 id="do_updateself-key-value"><span id="symbol-Store.__do_update">__do_update(self, key, value)</span></h4>
<p>Update a key-value pair and increment the version. Not thread-safe</p>
<h4 id="getself-key"><span id="symbol-Store.__get">__get(self, key)</span></h4>
<p>Retreive a value. Returns a clone of the Value. Not thread-safe.</p>
<h4 id="init__self"><span id="symbol-Store.__init__">__init__(self)</span></h4>
<h4 id="makeself-key"><span id="symbol-Store.__make">__make(self, key)</span></h4>
<p>Create a new key-value pair. Not thread-safe</p>
<h4 id="dumpself"><span id="symbol-Store.dump">dump(self)</span></h4>
<h4 id="setself-key-value"><span id="symbol-Store.set">set(self, key, value)</span></h4>
<p>Tries to update a value in the store. If the store is already in use a BusyRetry error is raised. If the value has been updated by another thread a ConcurrentUpdate error is raised</p>
<h4 id="set_valuesself-d"><span id="symbol-Store.set_values">set_values(self, D)</span></h4>
<p>Tries to update a selection of values in the store. If the store is already in use a BusyRetry error is raised. If one of the values has been updated by another thread a ConcurrentUpdate error is raised.</p>
<h4 id="usevarself-key-islocked"><span id="symbol-Store.usevar">usevar(self, key[, islocked])</span></h4>
<p>Tries to get an item from the store. Returns the requested Value object. If the store is already in use a BusyRetry error is raised.</p>
<h4 id="usingself-keys"><span id="symbol-Store.using">using(self, *keys)</span></h4>
<p>Tries to get a selection of items from the store. Returns a Collection dictionary containing the requested values. If the store is already in use a BusyRetry error is raised.</p>
<section>

</section>
<h1 id="axon.stm.value"><a href="/Docs/Axon/Axon.html" class="reference">Axon</a>.<a href="/Docs/Axon/Axon.STM.html" class="reference">STM</a>.<a href="/Docs/Axon/Axon.STM.Value.html" class="reference">Value</a></h1>
<h2 id="symbol-Value">class Value(object)</h2>
<section>
<p>Value(version, value, store, key) -&gt; new Value object</p>
<p>A simple versioned key-value pair which belongs to a thread-safe store</p>
<p>Arguments:</p>
<ul>
<li>version -- the initial version of the value</li>
<li>value -- the object's initial value</li>
<li>store -- a Store object to hold the value and it's history</li>
<li>key -- a key to refer to the value</li>
</ul>
<p>Note: You do not instantiate these - the Store does that</p>
</section>
<h3 id="methods-defined-here-2">Methods defined here</h3>
<h4 id="init__self-version-value-store-key"><span id="symbol-Value.__init__">__init__(self, version, value, store, key)</span></h4>
<p>x.__init__(...) initializes x; see x.__class__.__doc__ for signature</p>
<h4 id="repr__self"><span id="symbol-Value.__repr__">__repr__(self)</span></h4>
<h4 id="cloneself"><span id="symbol-Value.clone">clone(self)</span></h4>
<p>Returns a clone of the value</p>
<h4 id="commitself-1"><span id="symbol-Value.commit">commit(self)</span></h4>
<p>Commit a new version of the value to the store</p>
<h4 id="setself-value"><span id="symbol-Value.set">set(self, value)</span></h4>
<p>Set the value without storing</p>
<section>

</section>
</section>
</div>
<h1 id="feedback">Feedback</h1>
<p>Got a problem with the documentation? Something unclear that could be clearer? Want to help improve it? Constructive criticism is very welcome - especially if you can suggest a better rewording!</p>
<p>Please leave you feedback <a href="../../../cgi-bin/blog/blog.cgi?rm=viewpost&amp;nodeid=1142023701" class="reference">here</a> in reply to the documentation thread in the Kamaelia blog.</p>
<p><em>-- Automatic documentation generator, 09 Dec 2009 at 04:00:25 UTC/GMT</em></p>

</div> <!-- end section -->
</div> <!-- end page container -->

<div class="banner">
<a href="https://www.bbc.co.uk/rd"><img src="/site-resources/BBCRD_Logo.jpg"></a>
<P id="mini">  Kamaelia is an open source project originated from and guided
by <a href="https://www.bbc.co.uk/rd">BBC Research.</a> For more information
browse the site or get in contact.
<br>This is an ongoing community based development site.  As a result the
contents of this page is the opinions of the contributors of the pages
involved not the organisations involved.  Specificially, this page may
contain personal views which are not the views of the BBC.

<br>(C) Copyright 2004-2024 Kamaelia Contributors, including the British
Broadcasting Corporation, All Rights Reserved.
</div>
</body>
</html>
