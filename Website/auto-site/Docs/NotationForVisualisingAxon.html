<html>
<head>
<title> index </title>
<link rel=stylesheet type="text/css" href="/site-resources/base.css">
<link rel=stylesheet type="text/css" href="/site-resources/pandoc.css">
</head>
<body>
<div class="banner">
<P> <a href="/Home.html">Home</a> | 
    <a href="/About.html">About</a> | 
    <a href="/RecentChanges.html">Recent Changes</a> | 
    <a href="/Documentation.html">Documentation</a> |
    <a href="/Community.html">Community</a>
</div>
<div class="pagecontainer">
<div class="pagesection">
<div id="pagenote">
<p>Feb 2024 - This site, and Kamaelia are <a href="https://github.com/sparkslabs/kamaelia/issues/15">being updated</a>. There is significant work needed, and <a href="https://github.com/sparkslabs/kamaelia/pulls">PRs</a> are welcome.
</div>
<h1 id="a-notation-for-visualising-axon-systems">A Notation For Visualising Axon Systems</h1>
<div style="margin: auto; width: 50%; text-align: justify;">
<p><strong>Summary:</strong></p>
<p>This document presents a notation for diagrams to describe Axon systems. The notation is intended as both a design tool and documentation aid. Axon allows extraction of the information necessary to reconstruct the design from an active system. An overview of Axon - a software component system - is included.</p>
<p><strong>Keywords:</strong> Axon, Component, Software, Architecture, Parallel Processing, Concurrent, Signal Processing, Message Passing</p>
</div>
<h2 id="essential-elements-of-an-axon-system">1 Essential Elements of an Axon System</h2>
<p>Axon is a component system for creating large-scale highly parallel software systems. The system is designed to operate efficiently inside a single operating system process. (This is equivalent to a cook handling many tasks, rather than many cooks with many tasks.)<br />
A system in Axon has the following key elements:<br />
</p>
<ul>
<li>Components</li>
<li>Inboxes</li>
<li>Outboxes</li>
<li>Linkages</li>
</ul>
<p>Components perform processing in parallel with other components. A component contains inboxes and outboxes. Inboxes are used by components to receive messages. After processing, the results are placed into an outbox.</p>
<p>Components may contain other components forming systems. Messages pass between components along linkages which join outboxes to inboxes. (More specifically linkages join data sources to data sinks) This is analogous to internal mail inside an organisation and having the postman know where messages should be delivered.</p>
<p>Components normally perform processing by providing a means of handling a "pausable" function. Such functions voluntarily pause themselves using a form of return &amp; continue functionality provided by the language. As a result components are simply objects with lists of inboxes, outboxes and a wrapper for a pausable function. Users of the system customise components by providing alternative functionality for the various parts of the pausable function (initialisation, main loop, shutdown).<br />
</p>
<h2 id="overview-of-notation">2 Overview of Notation</h2>
<p>The purpose of this notation is to aid the following:<br />
</p>
<ul>
<li>Accessibility<br />
</li>
</ul>
<p>Design</p>
<ul>
<li>Documentation<br />
</li>
</ul>
<p>There are 3 main types of diagram this notation covers:<br />
</p>
<ul>
<li>Black box diagrams for single components. These show the external view of the component.</li>
<li>Glass box diagrams for component systems. These are used when a component contains other components, forming systems. These diagrams make this internal structure between subcomponents visible.<br />
</li>
<li>Lifecycle diagrams. These are a sequence of glass box diagrams showing how the component system changes with time.<br />
</li>
</ul>
<p>It's worth noting that black box diagrams are used on glass box diagrams, and that both black &amp; glass box diagrams are used on Lifecycle diagrams.<br />
</p>
<h3 id="black-box-single-component-static-view">2.1 Black Box Single Component Static View</h3>
<p>Figure 1 shows a black box view. This form of view does not contain any linkages, and simply shows public inboxes and outboxes. The notation provides clear differences between inboxes and outboxes.</p>
<div style="text-align: center;">
<p><img src="/t/BasicComponentBlackBox.png" /></p>
<p>Figure 1</p>
</div>
<p>Things to note regarding this diagram:<br />
</p>
<ul>
<li>The boundary of the component we are describing has a thick hexagonal boundary.</li>
<li><span style="font-weight: bold;">Inboxes</span> are indicated as essentially "arrow lines"<span style="font-weight: bold;"></span>pointing<span style="font-weight: bold;">into</span> the component.</li>
<li><span style="font-weight: bold;">Outboxes</span> are indicated as essentially "arrow lines"pointing<span style="font-weight: bold;">out from</span> component.</li>
<li>This only shows the external view of the object. No private/internal inboxes or outboxes are represented in this diagram.<br />
</li>
</ul>
<p>Figure 2 describes a sample existing component. A network server uses this component to send and receive data to a specific, already connected, client. For each connected client there is one connected socket adaptor.<br />
</p>
<div style="text-align: center;">
<p><img src="/t/ComplexComponentBlackBox.png" /></p>
<p>Figure 2</p>
</div>
<p><br />
This component has the following inputs and outputs:<br />
</p>
<ul>
<li>4 inboxes for receiving messages from other components</li>
<li>4 outboxes for sending messages to other components<br />
</li>
<li>Private to the component is a connected socket</li>
</ul>
<p>The connected socket forms a functional communication link to a system outside Axon. This behaviour is represented in the name of the component - it is the reason the component is called an adaptor.<br />
</p>
<p>Similarly a component designed to read from a file could have a single outbox, and no inboxes. Internally such a component would have a filehandle for reading data. In such a scenario, the filehandle would be created at component creation time. As data is made available this could be passed to the component's outbox. Due to the input from a non-Axon system, a file reader component operating in this manner would also be an adaptor.<br />
</p>
<p>A component that wrapped up all interaction with a GUI could have inboxes for receiving details of items to display, and outboxes for describing user events and input. This would also be an adaptor since it would be transforming input/output between the Axon system and the GUI system.</p>
<ul>
<li>A component can have no outboxes. This means the component is likely to produce output some other way - as audio, video, text to a screen, file, to a network connection, etc.</li>
<li>Components can also have no inboxes. Such components can take input from another source - such as from a file, network connection, keyboard, GUI, etc.<br />
</li>
</ul>
<h3 id="glass-box-component-system-static-view">2.2 Glass Box Component System Static View</h3>
<p>In the majority of cases, a glass box view will essentially be a snapshot of the system at a given point in time.<br />
</p>
<p>Figure 3 shows a rather complex glass box view.</p>
<div style="text-align: center;">
<p><img src="/t/ConnectedServerGlassBox.png" /></p>
<p>Figure 3</p>
</div>
<p>This diagram contains the following visual cues:<br />
</p>
<p>Once again, the border of the component being described has a thick hexagonal outline.</p>
<ul>
<li>For a toplevel component whose internals are being shown, a thick rectangular outline can be used instead to maximise drawing space!<br />
</li>
</ul>
<p>Public inboxes/outboxes are shown on the border of the component.</p>
<p>Private/internal inboxes or outboxes are shown as attached to the code running the component. The names are all preceded by an underscore.<br />
</p>
<p>We have represented the code of the component itself as a labelled hexagon with a dotted outline. If the component has no private inboxes/outboxes, we <em>could</em> omit the code representation from the diagram.</p>
<p>Linkages are indicated by arrows.<br />
</p>
<p>Subcomponents are indicated by hexagonal shapes.</p>
<p>Subcomponents defined at runtime, using the same interface, are shown with a dashed border.<br />
</p>
<ul>
<li><strong>Note:</strong> Such things are generally a configuration option when creating the component!<br />
</li>
</ul>
<p>There are clearly things going on here that are outside the scope of this component.<br />
</p>
<p>(Note this component has no outbox - output to an end-user is via the connected socket adaptor.)<br />
</p>
<p>The reasons for using this notation is as follows:<br />
</p>
<p>The region we are defining is clear and follows the same notation as a black box interface definition.</p>
<p>Subcomponents are shown in a different shape to indicate that this diagram does not define them. It defines their usage in a particular context.<br />
</p>
<p>Indicating a subcomponent with a dashed border indicates that we are not specifying a particular component in that section. We are defining that a component matching that interface will go there at runtime. Specifically this also requires that we have a method for changing which component this is at runtime.</p>
<p>Items are defined by functionality in these diagrams. Since all any linkage does is provide structure to the system, and indicate flow of messages, all linkages are drawn the same. That is all the linkages are shown as arrows. However it should be clear from the diagram that linkages fall into 3 categories:</p>
<ul>
<li>Linkages between outboxes and inboxes.</li>
<li>Linkages from a parent component inbox directly to a subcomponent's inbox.<br />
</li>
<li>Linkages from a subcomponent's outbox to a parent component's outbox.</li>
</ul>
<div class="boxright">
<p>One way of thinking about this is much like how a comic show time based events!</p>
</div>
<h3 id="lifecycle-dynamic-system-view">2.3 Lifecycle Dynamic System View</h3>
<p>Lifecycle/dynamic views are presented as a sequence of glass box diagrams. The purpose of a lifecycle/dynamic system view is to clearly present how the system changes with time. Since the structure of the system is extractable from an active system verification that the system is following expected behaviour is potentially checkable visually.<br />
</p>
<p>There is no additional notation added for dynamic systems. There is one major difference though: whilst a static view may have subcomponents with dashed borders, a dynamic/lifecycle diagram in general will not. A dashed border for a component indicates this component will be defined at runtime. A dynamic/lifecycle diagram as a whole indicates how the system works when it's running. Unless the entire system is parameterisable (which is possible), there will normally be no subcomponents with dashed borders.<br />
</p>
<p>An example HTTP server component could follow the following lifecycle:<br />
</p>
<ol type="1">
<li>The server component would be created:<br />
</li>
</ol>
<div style="text-align: center;">
<p><img src="/t/LifeCycle1.png" /></p>
</div>
<ol start="2" type="1">
<li>The server would allocate a listener:<br />
</li>
</ol>
<div style="text-align: center;">
<blockquote>
<p><img src="/t/LifeCycle2.png" /></p>
</blockquote>
</div>
<ol start="3" type="1">
<li>A client would connect, the server allocates a protocol handler and makes linkages:<br />
</li>
</ol>
<div style="text-align: center;">
<p><img src="/t/LifeCycle3.png" /></p>
</div>
<ol start="4" type="1">
<li>The client disconnects, the protocol handler &amp; connected socket handler are discarded, and the server listens for new connections:<br />
</li>
</ol>
<div style="text-align: center;">
<p><img src="/t/LifeCycle4.png" /></p>
</div>
<p>Steps 3 &amp; 4 then repeat.<br />
</p>
<div class="boxright">
<p>Valid reasons (non-exhaustive) for breaking these rules are:<br />
</p>
<ul>
<li>You're linking all outboxes to inboxes of the next component</li>
<li>Simplicity - you're writing a tutorial and want to skip details</li>
<li>Sanity - where it'd be mad to follow the rules</li>
<li>Experimentation - you're trying something new :)</li>
</ul>
</div>
<h2 id="summary">3 Summary</h2>
<p>This document has presented a notation for diagrams describing Axon components and systems. A summary of the notation is below. (it uses SHOULD/MUST /MAYin the same was an an RFC)<br />
</p>
<p>For all Axon diagrams:<br />
</p>
<p>The component being described/defined MUST be represented using a thick black border, and SHOULD use a hexagonal border.</p>
<p>Inboxes SHOULD be represented using arrow box-lines, pointing into the component.<br />
</p>
<p>Outboxes SHOULD be represented using using arrow box-lines, pointing out from the component.</p>
<ul>
<li><em>The only exception of inboxes &amp; outboxes is where the diagram would look unnecessarily complicated - if that's the case inboxes/outboxe MAY just the ends of a linkage.</em><br />
</li>
</ul>
<p>Public inboxes/outboxes MUST be attached to the border of the component.<br />
</p>
<p>The following applies to glass box diagrams:<br />
</p>
<ul>
<li>Subcomponents, linkages, and private inboxes/outboxes SHOULD only appear on glass box diagrams.<br />
</li>
<li>Private inboxes/outboxes SHOULD have a preceding underscore in their name and MUST be attached to a representation of the code.</li>
<li>Subcomponents MUST be represented using hexagons.</li>
<li>Subcomponents MAY be represented using a dashed border to indicate that a variety of subcomponents with identical inboxes/outboxes can be used in its place at runtime.</li>
<li>Linkages MUST be indicated using arrows.<br />
</li>
<li>The top level component MAY have a rectangular border to help with drawing space!</li>
</ul>
<p>Lifecycle diagrams:<br />
</p>
<ul>
<li>Indicate how the system will function at run time</li>
<li>Are generally glass box, rather than black box<br />
</li>
<li>Rarely contain subcomponents with dashed borders, unless the entire system is parameterisable at runtime</li>
</ul>
<p>Why use MAY/SHOULD/MUST? This notation forms a simple language, and by using it consistently we make it easier to pick up and run with Kamaelia systems.<br />
</p>
<h1 id="discussion">Discussion</h1>
<p>This document was used in Kamaelia development for a number of years, and has been refined over time.</p>

</div> <!-- end section -->
</div> <!-- end page container -->

<div class="banner">
<a href="https://www.bbc.co.uk/rd"><img src="/site-resources/BBCRD_Logo.jpg"></a>
<P id="mini">  Kamaelia is an open source project originated from and guided
by <a href="https://www.bbc.co.uk/rd">BBC Research.</a> For more information
browse the site or get in contact.
<br>This is an ongoing community based development site.  As a result the
contents of this page is the opinions of the contributors of the pages
involved not the organisations involved.  Specificially, this page may
contain personal views which are not the views of the BBC.

<br>(C) Copyright 2004-2024 Kamaelia Contributors, including the British
Broadcasting Corporation, All Rights Reserved.
</div>
</body>
</html>
