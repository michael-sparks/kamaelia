<html>
<head>
<title> index </title>
<link rel=stylesheet type="text/css" href="/site-resources/base.css">
<link rel=stylesheet type="text/css" href="/site-resources/pandoc.css">
</head>
<body>
<div class="banner">
<P> <a href="/Home.html">Home</a> | 
    <a href="/About.html">About</a> | 
    <a href="/RecentChanges.html">Recent Changes</a> | 
    <a href="/Documentation.html">Documentation</a> |
    <a href="/Community.html">Community</a>
</div>
<div class="pagecontainer">
<div class="pagesection">
<div id="pagenote">
<p>March 2024 - This site, and Kamaelia are <a href="https://github.com/sparkslabs/kamaelia/issues/15">being updated</a>. There is significant work needed, and <a href="https://github.com/sparkslabs/kamaelia/pulls">PRs</a> are welcome.
</div>
<p><span style="font-size: 24pt; font-weight: 600;">Cookbook</span></p>
<p><span style="font-size: 18pt;">How can I...?</span></p>
<div class="boxright">
<p>Other ways of using Kamaelia<br />
</p>
<ul>
<li><a href="../../../Cookbook/LikeFile.html">Using Kamaelia
concurrently in other systems</a></li>
</ul>
<p>This section contains a number of examples in a number of different
application areas. These are all included in the Kamaelia distribution,
but are provided here for convenience. See also the <a
href="/Docs/">documentation</a> in the older structure.</p>
<p>Last Editted: Patrick, 03 Aug 2007<br />
</p>
<h3 id="linking-components-together">Linking components together</h3>
<h1 id="cookbook-pipelines-and-graphlines">Cookbook : Pipelines and
Graphlines</h1>
<div class="boxright">
<p><strong>Discussion</strong> Please discuss this on <a
href="http://backend.kamaelia.org/CookbookTranscludeDiscuss.html">the
discussion page</a> for this page</p>
</div>
<p>Fairly early on you'll want a quick an easy way to link your
components together. To actually build a useful system you need to set
up linkages to get data from one component's outbox to another
component's inbox. <a
href="/Cookbook/Pipelines.html"><strong>Pipelines</strong></a> and <a
href="/Cookbook/Graphlines.html"><strong>Graphlines</strong></a> are the
two simplest and most common ways of doing this.<br />
<br />
</p>
<div class="boxright">
<p>Find out more about using Pipelines <a
href="/Cookbook/Pipelines.html">here</a></p>
</div>
<p>Pipeline and Graphline are, themselves, components. Pipeline wires
components together in a long chain. For example:<br />
</p>
<blockquote>
<pre><code>from Kamaelia.Chassis.Pipeline import Pipeline

from Kamaelia.Internet.Multicast_transceiver import Multicast_transceiver
from Kamaelia.Protocol.SimpleReliableMulticast import SRM_Sender
from Kamaelia.Protocol.Packetise import MaxSizePacketiser

Pipeline( RateControlledFileReader(&quot;myaudio.mp3&quot;,readmode=&quot;bytes&quot;,rate=128000/8),
          SRM_Sender(),
          MaxSizePacketiser(),
          Multicast_transceiver(&quot;0.0.0.0&quot;, 0, &quot;224.168.2.9&quot;, 1600),
        ).run()</code></pre>
</blockquote>
<div class="boxright">
<p>Find out more about Graphlines <a
href="/Cookbook/Graphlines.html">here</a></p>
</div>
<p>Whereas a Graphline wires components together in any way you want -
you specify each individual link. For example:<br />
</p>
<pre style="margin-left: 40px;"><code>from Kamaelia.UI.Pygame.Button import Button
from Kamaelia.UI.Pygame.Image import Image

from Kamaelia.Util.Chooser import Chooser

from Kamaelia.Chassis.Graphline import Graphline

files = [ &quot;slide1.gif&quot;, &quot;slide2.gif&quot;, .... &quot;slide99.gif&quot; ]

Graphline(
     CHOOSER  = Chooser(files),
     IMAGE    = Image(size=(800,600), position=(8,48)),
     NEXT     = Button(caption=&quot;Next&quot;,     msg=&quot;NEXT&quot;, position=(72,8)  ),
     PREVIOUS = Button(caption=&quot;Previous&quot;, msg=&quot;PREV&quot; ,position=(8,8)   ),
     FIRST    = Button(caption=&quot;First&quot;,    msg=&quot;FIRST&quot;,position=(256,8) ),
     LAST     = Button(caption=&quot;Last&quot;,     msg=&quot;LAST&quot; ,position=(320,8) ),
     linkages = {
        (&quot;NEXT&quot;,     &quot;outbox&quot;) : (&quot;CHOOSER&quot;, &quot;inbox&quot;),
        (&quot;PREVIOUS&quot;, &quot;outbox&quot;) : (&quot;CHOOSER&quot;, &quot;inbox&quot;),
        (&quot;FIRST&quot;,    &quot;outbox&quot;) : (&quot;CHOOSER&quot;, &quot;inbox&quot;),
        (&quot;LAST&quot;,     &quot;outbox&quot;) : (&quot;CHOOSER&quot;, &quot;inbox&quot;),

        (&quot;CHOOSER&quot;,  &quot;outbox&quot;) : (&quot;IMAGE&quot;,   &quot;inbox&quot;),
     }
).run()</code></pre>
<p>-- 17 Dec 2006 - Matt Hammond<br />
</p>
<p><br />
</p>
<h1 id="cookbook-pipelines">Cookbook : Pipelines</h1>
<p>Pipelines are one of the simplest ways to wire components together. A
Pipeline wires components together in a long chain.<br />
<br />
Here's a simple pipeline we want to build that sends a file over
multicast, using a simple protocol to ensure reliable
transmission:<br />
<br />
</p>
<div data-align="center">
<figure>
<img src="/images/pipeline1_idea.gif"
alt="We want to wire a set of components together in a long chain (a pipeline)" />
<figcaption aria-hidden="true">We want to wire a set of components
together in a long chain (a pipeline)</figcaption>
</figure>
</div>
<p><br />
We could build this by writing a new component with a whole bunch of
self.link() calls to link each outbox to the next inbox. But that is a
lot of code to write and rather tedious! ... surely there must be an
easier way?<br />
<br />
... And so the Pipeline component comes to the rescue! No need to write
a whole new component, simply use a Pipeline component like this:<br />
</p>
<blockquote>
<pre><code>from Kamaelia.Chassis.Pipeline import Pipeline

from Kamaelia.Internet.Multicast_transceiver import Multicast_transceiver
from Kamaelia.Protocol.SimpleReliableMulticast import Annotator
from Kamaelia.Protocol.SimpleReliableMulticast import _Framer
from Kamaelia.Protocol.SimpleReliableMulticast import _DataChunker
from Kamaelia.Protocol.Packetise import MaxSizePacketiser
from Kamaelia.File.Reading import RateControlledFileReader

Pipeline( RateControlledFileReader(&quot;myaudio.mp3&quot;,readmode=&quot;bytes&quot;,rate=128000/8),
          Annotator(),
          _Framer(),
          _DataChunker(),
          MaxSizePacketiser(),
          Multicast_transceiver(&quot;0.0.0.0&quot;, 0, &quot;224.168.2.9&quot;, 1600),
        ).run()</code></pre>
</blockquote>
<p>You can find this code in
<code>Kamaelia/Examples/Multicast/SimpleReliableMulticast</code><br />
</p>
<p>So what did Pipeline actually do?</p>
<figure>
<img src="/images/pipeline1_intention.gif"
alt="Pipeline component does this for us" />
<figcaption aria-hidden="true">Pipeline component does this for
us</figcaption>
</figure>
<p>It wires the components into a chain inside itself - linking outboxes
to inboxes. When we call the run() method, the Kamaelia system starts,
and the pipeline component is activated. It in turn, activates all the
components inside.<br />
</p>
<h3 id="how-are-the-components-linked-together">How are the components
linked together?</h3>
<div class="boxright">
<p><strong>Just like unix pipes</strong><br />
"inbox" and "outbox" are a lot like standard-input and standard-output
for command line programs. When you pipe programs together on a unix
shell, the standard-output of one program gets sent to the
standard-input of the next.<br />
<br />
"control" and "signal" are analogous to standard-error. In practice
Kamaelia components use it to signal when they are finished.<br />
</p>
</div>
<p><br />
More specifically, Pipeline links one component to the next in the
chain. It links the "outbox" and "signal" outboxes of one component to
the "inbox" and "control" inboxes on the next one:<br />
</p>
<ul>
<li>The "inbox" and "outbox" boxes are the ones most components use to
take in and send out data. So for example, whatever the
RateControlledFileReader component reads gets sent to the Annotator
component.<br />
<br />
</li>
<li>The "control" and "signal" boxes are used to send the shutdown
message when a component has finished, and wants to tell the next.</li>
</ul>
<p>So, if we look at precisely what linkages are made, we see something
like this:<br />
<br />
</p>
<div data-align="center">
<figure>
<img src="/images/pipeline1_inside.gif"
alt="Pipeline component links" />
<figcaption aria-hidden="true">Pipeline component links</figcaption>
</figure>
</div>
<p><br />
</p>
<h3 id="pipeline-is-a-component-too-...-time-to-go-modular">Pipeline is
a component too ... time to go modular!</h3>
<p>The Pipeline also links its own inboxes and outboxes to the start and
the end (respectively) of the chain. Pipeline is, after all, a component
too, so it makes sense to be able to send and receive messages to/from
the pipeline of components within using its inboxes and outboxes. Think
of it as a kind of container.<br />
<br />
You can therefore use a Pipeline as a way to wrap up a useful pipelined
set of components into a single bundle that you can then reuse
elsewhere.<br />
<br />
For example, we could separate the components that make the multicast
reliability protocol into another Pipeline, and simply include it like
another component:<br />
</p>
<blockquote>
<pre><code>Pipeline( RateControlledFileReader(&quot;myaudio.mp3&quot;,readmode=&quot;bytes&quot;,rate=128000/8),
          Pipeline( Annotator(),
                     _Framer(),
                     _DataChunker(),
                   ),
          MaxSizePacketiser(),
          Multicast_transceiver(&quot;0.0.0.0&quot;, 0, &quot;224.168.2.9&quot;, 1600),
        ).run()</code></pre>
</blockquote>
<p>We don't have to call the run() or activate() method of the inner
pipeline since, just like the other components, they'll all be activated
by the main pipeline when it starts.<br />
<br />
In fact, we could actually move that into a completely separate
function, that simply returns the pipeline:<br />
</p>
<blockquote>
<pre><code>def SRM_Sender():
   return Pipeline( Annotator(),
                    _Framer(),
                    _DataChunker(),
                  )</code></pre>
</blockquote>
<p>Now we can call that function to put the sub pipeline into the
chain:<br />
</p>
<blockquote>
<pre><code>Pipeline( RateControlledFileReader(&quot;myaudio.mp3&quot;,readmode=&quot;bytes&quot;,rate=128000/8),
          SRM_Sender(),
          MaxSizePacketiser(),
          Multicast_transceiver(&quot;0.0.0.0&quot;, 0, &quot;224.168.2.9&quot;, 1600),
        ).run()</code></pre>
</blockquote>
<p>We can now, for the most part, use SRM_Sender just like any other
component.<br />
<br />
This hopefully makes the design of the system more modular and clearer,
and also give us a re-usable component for applying our multicast
reliability protocol - which we previously didn't have. In fact, this
has already been done so you can simply import it and use it:<br />
</p>
<blockquote>
<pre><code>from Kamaelia.Protocol.SimpleReliableMulticast import SRM_Sender

Pipeline( RateControlledFileReader(&quot;myaudio.mp3&quot;,readmode=&quot;bytes&quot;,rate=128000/8),
          SRM_Sender(),
          MaxSizePacketiser(),
          Multicast_transceiver(&quot;0.0.0.0&quot;, 0, &quot;224.168.2.9&quot;, 1600),
        ).run()</code></pre>
</blockquote>
<h3 id="need-more-flexibility">Need more flexibility?</h3>
<p>Pipelines are not the only quick and easy way to link up components.
Perhaps you need to make different links? Try a <a
href="/Cookbook/Graphlines.html">Graphline</a> instead.<br />
<br />
-- 18 Dec 2006 - Matt Hammond<br />
<br />
</p>
<h1 id="cookbook-graphlines">Cookbook : Graphlines</h1>
<p>A Graphline provides a flexible way to link inboxes and outboxes in
any way you wish. Whereas a Pipeline constrains your components to be
wired into ... a pipeline ... with Graphline you specify each link
explicitly.</p>
<p>Suppose we want to build a simple slideshow application, where pygame
Button components control a Chooser component that sends filenames for
each slide to a pygame Image display component:</p>
<p><img src="/images/graphline1_idea.gif" /></p>
<p>We could build this by writing a new component with a whole bunch of
self.link() calls to link each outbox to the next inbox. But that is a
lot of code to write and rather tedious! ... surely there must be an
easier way?<br />
<br />
... You need the graphline component! No need to write a whole new
component, simply use a Graphline component like this:</p>
<pre style="margin-left: 40px;"><code>from Kamaelia.Chassis.Graphline import Graphline

from Kamaelia.UI.Pygame.Button import Button
from Kamaelia.UI.Pygame.Image import Image
from Kamaelia.Util.Chooser import Chooser

files = [ &quot;slide1.gif&quot;, &quot;slide2.gif&quot;, .... &quot;slide99.gif&quot; ]

Graphline(
     CHOOSER  = Chooser(files),
     IMAGE    = Image(size=(800,600), position=(8,48)),
     NEXT     = Button(caption=&quot;Next&quot;,     msg=&quot;NEXT&quot;, position=(72,8)  ),
     PREVIOUS = Button(caption=&quot;Previous&quot;, msg=&quot;PREV&quot; ,position=(8,8)   ),
     FIRST    = Button(caption=&quot;First&quot;,    msg=&quot;FIRST&quot;,position=(256,8) ),
     LAST     = Button(caption=&quot;Last&quot;,     msg=&quot;LAST&quot; ,position=(320,8) ),

     linkages = {
        (&quot;NEXT&quot;,     &quot;outbox&quot;) : (&quot;CHOOSER&quot;, &quot;inbox&quot;),
        (&quot;PREVIOUS&quot;, &quot;outbox&quot;) : (&quot;CHOOSER&quot;, &quot;inbox&quot;),
        (&quot;FIRST&quot;,    &quot;outbox&quot;) : (&quot;CHOOSER&quot;, &quot;inbox&quot;),
        (&quot;LAST&quot;,     &quot;outbox&quot;) : (&quot;CHOOSER&quot;, &quot;inbox&quot;),

        (&quot;CHOOSER&quot;,  &quot;outbox&quot;) : (&quot;IMAGE&quot;,   &quot;inbox&quot;),
     }
).run()</code></pre>
<p>What you see here is slightly abridged for clarity. You can find the
full version in
<code>Kamaelia/Examples/SimpleGraphicalApps/Slideshows</code></p>
<p>What did we just do? Simple:</p>
<ol type="1">
<li><p>Write each component as a named argument<br />
</p>
<pre style="margin-left: 40px;"><code>     CHOOSER  = Chooser(files),
     IMAGE    = Image(size=(800,600), position=(8,48)),
     NEXT     = Button(caption=&quot;Next&quot;,     msg=&quot;NEXT&quot;, position=(72,8)  ),
     PREVIOUS = Button(caption=&quot;Previous&quot;, msg=&quot;PREV&quot; ,position=(8,8)   ),
     FIRST    = Button(caption=&quot;First&quot;,    msg=&quot;FIRST&quot;,position=(256,8) ),
     LAST     = Button(caption=&quot;Last&quot;,     msg=&quot;LAST&quot; ,position=(320,8) ),</code></pre>
<p><br />
</p></li>
<li><p>...then write the linkages you want as the 'linkages' argument in
a dictionary:<br />
</p>
<pre style="margin-left: 40px;"><code>     linkages = {
        (&quot;NEXT&quot;,     &quot;outbox&quot;) : (&quot;CHOOSER&quot;, &quot;inbox&quot;),
        (&quot;PREVIOUS&quot;, &quot;outbox&quot;) : (&quot;CHOOSER&quot;, &quot;inbox&quot;),
        (&quot;FIRST&quot;,    &quot;outbox&quot;) : (&quot;CHOOSER&quot;, &quot;inbox&quot;),
        (&quot;LAST&quot;,     &quot;outbox&quot;) : (&quot;CHOOSER&quot;, &quot;inbox&quot;),

        (&quot;CHOOSER&quot;,  &quot;outbox&quot;) : (&quot;IMAGE&quot;,   &quot;inbox&quot;),
     }</code></pre></li>
</ol>
<p>For each linkage we want, we write a mapping in the dictionary from a
(component, outbox) to a (component, inbox) We refer to the components
by the names we just gave them, as strings. We reference the inboxes and
outboxes by their names too.</p>
<p>So, for example:<br />
</p>
<pre style="margin-left: 40px;"><code>(&quot;NEXT&quot;,&quot;outbox&quot;) : (&quot;CHOOSER&quot;,&quot;inbox&quot;)</code></pre>
<p>specifies that you want the "outbox" outbox of the "Next" Button to
be linked to the "inbox" inbox of the Chooser.<br />
<br />
</p>
<h3 id="making-links-to-the-outside-world">Making links to the outside
world</h3>
<p>So the Graphline defined above wires up the Chooser, Image and 4
Button components inside itself - like Pipeline it is a kind of
container:<br />
</p>
<div data-align="center">
<p><img src="/images/graphline1_intention.gif" /><br />
</p>
</div>
<p><br />
If we look in more detail, the links made are actually like this:<br />
<br />
</p>
<div style="text-align: center;">
<figure>
<img src="../../../images/graphline1_inside.gif"
alt="A diagram showing how the components inside the example graphline are linked up" />
<figcaption aria-hidden="true">A diagram showing how the components
inside the example graphline are linked up</figcaption>
</figure>
</div>
<p><br />
Just like the Pipeline component, a Graphline has its own inboxes and
outboxes. You can specify links to and from these by using the empty
string to name the component.<br />
<br />
For example, we might want to be able to send instructions to the
Chooser from outside this graphline, in which case we would add this to
the set of linkages:<br />
</p>
<pre style="margin-left: 40px;"><code>        (&quot;&quot;, &quot;inbox&quot;) : (&quot;NEXT&quot;, &quot;inbox&quot;),</code></pre>
<p>By using a name for a component that we've not used (in this case
simply the empty string suffices) we're telling Graphline to use its own
inbox.<br />
<br />
We could do the same for outboxes too if we want. For example, we could
ask for the outbox of the Image component to be linked to the
Graphline's outbox:<br />
</p>
<pre style="margin-left: 40px;"><code>        (&quot;IMAGE&quot;, &quot;outbox&quot;) : (&quot;&quot;,     &quot;outbox&quot;),</code></pre>
<p>In fact, if you also refer to an inbox or outbox name for the
Graphline that does not exist. Graphline will simply create it. This
means you can use a Graphline as a container, giving it whatever inboxes
and outboxes you need - not just the 'standard' ones that most
components have.<br />
<br />
Just like with Pipeline, Graphline is a fully fledged component itself,
so you can put a Graphline inside a Pipeline, or a Pipeline inside a
Graphline, or any other combination you care to choose. Again, it can be
a good way of making your system more modular, by separating off a
little group of components into a separate functional unit.<br />
</p>
<blockquote>
<p><br />
</p>
</blockquote>
<h1 id="cookbook-carousels">Cookbook : Carousels</h1>
<p>So you've built your components and wired them up using <a
href="/Cookbook/Pipelines.html">Pipelines</a> and <a
href="/Cookbook/Graphlines.html">Graphlines</a> . But what do you do if
you want to create or initialise a component at runtime?</p>
<p>Perhaps you can't know the value of some arguments until you start
reading that input file. Or maybe you want to process several streams of
data in sequence, but the component you want to use isn't designed to
process several streams back to back. This is where a component like the
<em>Carousel</em> comes in.</p>
<p>The Carousel gives us a way to create a component on-the-fly in
response to being sent a message.<br />
</p>
<h3 id="for-example...">For example...</h3>
<p>Suppose we want to play an MP3 file ... we could use a simple
pipeline like this:<br />
</p>
<blockquote>
<pre><code>from Kamaelia.File.Reading import RateControlledFileReader
from Kamaelia.Audio.Codec.PyMedia.Decoder import Decoder
from Kamaelia.Audio.PyMedia.Output import Output
from Kamaelia.Chassis.Pipeline import Pipeline

import sys
mp3filename=sys.argv[1]

Pipeline( RateControlledFileReader( mp3filename, readmode=&quot;bytes&quot;, rate=256000/8),
          Decoder(&quot;mp3&quot;),
          Output(sample_rate=44100, channels=2, format=&quot;S16_LE&quot;),
        ).run()</code></pre>
</blockquote>
<p><br />
That is all very nice; but what if we get the sample rate, number of
channels or format wrong? We can't get this information until we start
decoding it. If we get it wrong then the audio may be corrupted or
played at the wrong speed!<br />
<br />
It would be great if, at runtime, we could create the audio playback
(Output) component in response to receiving a message from the MP3
decoder containing the audio format:<br />
<br />
</p>
<div data-align="center">
<p><img src="/images/carousel1_idea.gif" /><br />
</p>
</div>
<p><br />
The PyMedia MP3 Decoder component we are using helpfully sends out a
message containing the information we need, so we can use the Carousel
component to do it like this:<br />
</p>
<blockquote>
<pre><code>from Kamaelia.Chassis.Graphline import Graphline
from Kamaelia.Chassis.Carousel import Carousel

def makeAudioOutput(metadata):
    return Output( metadata[&quot;sample_rate&quot;],
                   metadata[&quot;channels&quot;],
                   metadata[&quot;format&quot;]
                 )

Graphline( READ = RateControlledFileReader( mp3filename, readmode=&quot;bytes&quot;, rate=256000/8),
           DECODE = Decoder(&quot;mp3&quot;),
           OUTPUT = Carousel( makeAudioOutput ),
           linkages = {
               (&quot;READ&quot;,   &quot;outbox&quot;) : (&quot;DECODE&quot;, &quot;inbox&quot;),
               (&quot;DECODE&quot;, &quot;outbox&quot;) : (&quot;OUTPUT&quot;, &quot;inbox&quot;),
               (&quot;DECODE&quot;, &quot;format&quot;) : (&quot;OUTPUT&quot;, &quot;next&quot;),

               (&quot;READ&quot;,   &quot;signal&quot;) : (&quot;DECODE&quot;, &quot;control&quot;),
               (&quot;DECODE&quot;, &quot;signal&quot;) : (&quot;OUTPUT&quot;, &quot;control&quot;),
           }
         ).run()</code></pre>
</blockquote>
<p>This example is wired up using a Graphline component - find out more
about Graphlines <a href="/Cookbook/Graphlines.html">here</a> .<br />
</p>
<h3 id="so-what-does-this-do">So what does this do?</h3>
<h3 id="section"></h3>
<p>The MP3 Decoder component we are using helpfully sends out the format
of the decoded audio out of its "format" outbox, so we link this to the
Carousel's "next" inbox to control it. A message from the decoder wil
look like this:<br />
</p>
<blockquote>
<pre><code>{ &quot;sample_rate&quot; : 44100, &quot;channels&quot;:2, &quot;format&quot;:&quot;S16_LE&quot; }</code></pre>
</blockquote>
<p>We've also written a function makeAudioOutput(). When called with the
message as its argument; it returns a new Output component set up with
the right sample rate, number of channels, and format.</p>
<p>We give this function to the Carousel. Note that we don't call it -
we just give it the function. The Carousel calls it when it receives a
message on its "next" inbox and therefore needs to create the
component:</p>
<p><br />
</p>
<div data-align="center">
<p><img src="/images/carousel_anim.gif" /></p>
</div>
<p><br />
</p>
<ol type="1">
<li>The Carousel receives a message on its "next" inbox, containing the
format of the audio<br />
</li>
<li>The Carousel calls our <em>makeAudioOutput</em> function, passing it
this message as its parameter<br />
</li>
<li>Our function returns a new Output component, ready to be used.<br />
</li>
<li>Carousel links the new Output component up to use its own inboxes
and outboxes</li>
</ol>
<p>So when the raw audio samples start to arrive at its inbox, there
will be a new Output component already linked in to receive them.<br />
Note that it does not link the "signal" outbox - this is so that when
the component finishes and sends its own shutdown message, this doesn't
get passed on - after all, you might want to reuse the Carousel with
another component.<br />
</p>
<h3 id="so-why-is-it-called-a-carousel-then">So why is it called a
"Carousel" then?</h3>
<h3 id="section-1"></h3>
<p>If you send another message to the "next" inbox, then the component
gets replaced. Any existing component is told to shutdown and is thrown
away as soon as possible, and a new one is created, by calling our
function with the new message as the parameter.<br />
<br />
This kind of behaviour is a little like the carousel on an old slide
projector - when you want to move on, the old item is swapped for the
next one. Alternatively think of a fairground merry-go-round carousel -
where one horse comes by after another.<br />
<br />
For example, suppose we want to improve our MP3 player by making it play
multiple files back to back. We could put everything in a Carousel, then
when it has finished, it could send us a message. We could then respond
by sending it the next filename to play, and letting it start again.
Something like this:<br />
</p>
<div data-align="center">
<p><img src="/images/carousel_anim2.gif" /><br />
</p>
<div data-align="left">
<p>We can do this by using a Chooser component for the playlist and
putting our existing player inside a Carousel. When all the player
components finish, our Carousel will send out a "next" message from its
"requestNext" outbox, which we can use to cause our Chooser to send back
the next filename:</p>
<p><img src="/images/carousel3.gif" /></p>
<p>Notice that we can also wire up the "signal" and "control" boxes, so
that when the Chooser has no more names in its playlist, it can tell our
player Carousel to shut down.<br />
</p>
<p>So now lets build this! First, lets make a function that we will give
to the Carousel for it to use to create our player:<br />
</p>
<blockquote>
<pre><code>def makePlayer(mp3filename):
    return Graphline(
        READ = RateControlledFileReader( mp3filename, readmode=&quot;bytes&quot;, rate=256000/8),
        DECODE = Decoder(&quot;mp3&quot;),
        OUTPUT = Carousel( makeAudioOutput ),
        linkages = {
            (&quot;READ&quot;,   &quot;outbox&quot;) : (&quot;DECODE&quot;, &quot;inbox&quot;),
            (&quot;DECODE&quot;, &quot;outbox&quot;) : (&quot;OUTPUT&quot;, &quot;inbox&quot;),
            (&quot;DECODE&quot;, &quot;format&quot;) : (&quot;OUTPUT&quot;, &quot;next&quot;),

            (&quot;&quot;,      &quot;control&quot;) : (&quot;READ&quot;,   &quot;control&quot;),
            (&quot;READ&quot;,   &quot;signal&quot;) : (&quot;DECODE&quot;, &quot;control&quot;),
            (&quot;DECODE&quot;, &quot;signal&quot;) : (&quot;OUTPUT&quot;, &quot;control&quot;),
            (&quot;OUTPUT&quot;, &quot;signal&quot;) : (&quot;&quot;,       &quot;signal&quot;),
        }
      )</code></pre>
</blockquote>
</div>
</div>
<p>This is almost identical to our player from before. Notice we've
added extra links to make sure shutdown messages can get into and out of
the Graphline. This is important, as Carousel will be listening for our
Graphline sending the shutdown message.<br />
<br />
Now lets wire it all up! We will use a <em>ForwardIteratingChooser</em>
because it will send a shutdown message once all the filenames have been
iterated over:<br />
</p>
<blockquote>
<pre><code>from Kamaelia.Util.Chooser import ForwardIteratingChooser

filenames = argv[1:]

Graphline( PLAYLIST = ForwardIteratingChooser(filenames),
           PLAYER   = Carousel( makePlayer, make1stRequest=True ),
           linkages = {
               (&quot;PLAYER&quot;,   &quot;requestNext&quot;) : (&quot;PLAYLIST&quot;, &quot;inbox&quot;),
               (&quot;PLAYLIST&quot;, &quot;outbox&quot;)      : (&quot;PLAYER&quot;,   &quot;next&quot;),

               (&quot;PLAYLIST&quot;, &quot;signal&quot;) : (&quot;PLAYER&quot;, &quot;control&quot;),
           }
         ).run()</code></pre>
</blockquote>
<p>Notice that we have asked the Carousel to make the 1st request. What
this means is that as soon as it starts it will send out its request for
the next item - instead of just waiting. This gets things going.<br />
<br />
So there we have it, a simple mp3 playlist system, built entirely in
Kamaelia, using Carousels to create components with the right settings
when we need them.<br />
</p>
<p>-- 19 Dec 2006 - Matt Hammond<br />
</p>
<h1 id="cookbook-backplanes">Cookbook : Backplanes</h1>
<p>Backplanes provide an easy way to distribute data from many sources
to many destinations. For example<br />
</p>
<h3 id="serving-to-multiple-clients">Serving to multiple clients</h3>
<p>For example, perhaps we want to build a server where each client that
connects receives a copy of a stream of data - perhaps the current time.
First, lets create our source of time data:</p>
<blockquote>
<pre><code>from Axon.ThreadedComponent import threadedcomponent
import time

class TimeTick(threadedcomponent):
    def main(self):
        prev=&quot;&quot;
        while 1:
            now = time.asctime() + &quot;\n&quot;
            if now!=prev:
                self.send(now, &quot;outbox&quot;)
                prev=now
            else:
                self.pause(0.1)</code></pre>
</blockquote>
<p>We're going to use SimpleServer to provide a simple TCP server to
clients. Every time a client connects, we could make a new, private
instance of TimeTick to handle that client. Alternatively we could make
a single TimeTick component that sends (publishes) its messages to a
Backplane:<br />
<br />
</p>
<blockquote>
<pre><code>from Kamaelia.Util.Backplane import Backplane
from Kamaelia.Util.Backplane import PublishTo
from Kamaelia.Chassis.Pipeline import Pipeline

Backplane(&quot;TIME&quot;).activate()

Pipeline( TimeTick(),
          PublishTo(&quot;TIME&quot;),
        ).activate()</code></pre>
</blockquote>
<p>Then for each client that connects, we ask SimpleServer to make a
component that fetches (subscribes) from that same backplane:<br />
<br />
</p>
<blockquote>
<pre><code>from Kamaelia.Util.Backplane import SubscribeTo
from Kamaelia.Chassis.ConnectedServer import SimpleServer

SimpleServer(protocol=lambda : SubscribeTo(&quot;TIME&quot;), port=1500).run()</code></pre>
</blockquote>
<h3 id="so-whats-going-on">So what's going on?</h3>
<p>Notice we've named the Backplane "TIME" to distinguish it from other
Backplanes. You can therefore have as many Backplanes in a system as you
like. The SubscribeTo and PublishTo components connect to the right
backplane because they look it up (by the name) using the Coordinating
Assistant Tracker (CAT). Once the subscribers and publishers are all
linked up, you get something like this:<br />
<br />
</p>
<div data-align="center">
<p><img src="/images/backplane1.gif"
alt="PublishTo components send data to the Backplane. The Backplane then sends it onto ALL SubscribeTo components subscribed to it." /><br />
</p>
</div>
<p><br />
PublishTo components send anything that arrives at their "inbox" inbox
onto the Backplane. SubscribeTo components talk to the backplane and
send on anything they receive from it to their "outbox" outbox. The
Backplane itself acts like a splitter component - anything it receives
is sent onto all outputs; in this case - all subscribers.<br />
</p>
<h3 id="couldnt-we-have-done-that-more-simply">Couldn't we have done
that more simply?</h3>
<p>For a really simple example like this, there is little or no benefit
of doing it this way ... in fact, it might seem like unnecessary extra
effort and components! However, the real power is that all the clients
are sharing the same data source.</p>
<h3 id="a-simple-relay-server">A simple relay server</h3>
<p>Perhaps, for example, our source of data is actually coming from
another server (say "foo.bar.com" on port 1600). Using a backplane, its
easy to build a relay server capable of replicating the data to multiple
clients:</p>
<blockquote>
<pre><code>from Kamaelia.Internet.TCPClient import TCPClient

Pipeline( TCPClient(&quot;foo.bar.com&quot;, port=1600),
          PublishTo(&quot;DATA&quot;),
        ).activate()

Backplane(&quot;DATA&quot;).activate()

SimpleServer(protocol=lambda : SubscribeTo(&quot;DATA&quot;), port=1600).run()</code></pre>
</blockquote>
<h3 id="an-aggregating-logger...">An aggregating logger...</h3>
<p>Backplanes aren't just useful for distributing data in a one-to-many
fashion; they can also be used for many-to-one or many-to-many. For
example, we can use a Backplane to build a logging server capable of
logging, to a single file, data received from multiple clients. In
effect, a simple aggregating logger:</p>
<blockquote>
<pre><code>from Kamaelia.Visualisation.PhysicsGraph.chunks_to_lines import chunks_to_lines
from Kamaelia.File.Writing import SimpleFileWriter

def sendToBackplane():
    return Pipeline( chunks_to_lines(),
                      PublishTo(&quot;LOGGER&quot;),
                    )

SimpleServer(protocol=sendToBackplane, port=1500).activate()

Pipeline( SubscribeTo(&quot;LOGGER&quot;),
          SimpleFileWriter(&quot;log.data&quot;),
        ).activate()

Backplane(&quot;LOGGER&quot;).run()</code></pre>
</blockquote>
<h3 id="that-can-also-be-a-relay">...that can also be a relay</h3>
<p>Because we use a Backplane and a SimpleServer chassis, the client
connections are not hard wired - clients can connect and disconnect
whenever they choose. In fact, we could extend this further, by allowing
clients to connect on a different port to receive a live stream of the
aggregated logging data:</p>
<blockquote>
<pre><code>SimpleServer(protocol=SubscribeTo(&quot;LOGGER&quot;), port=1501).activate()</code></pre>
</blockquote>
<p>Our aggregating logger is now also a relay, using the backplane to
distribute messages from many sources to many destinations.</p>
<p><br />
-- Jan 2007, Matt<br />
</p>
<h3 id="build-tcp-based-clients-and-servers">Build TCP Based Clients and
Servers</h3>
<p><span style="font-size: 24pt; font-weight: 600;">Cookbook
Example</span></p>
<p><span style="font-size: 18pt;">How can I...?</span></p>
<p>Example 1: Building a Simple TCP Based Server that allows multiple
connections at once and sends a fortune cookie to the client. Includes
simple TCP based client that displays the fortune cookie. <span
style="font-weight: 600;">Components used:</span><a
href="/Components/pydoc/Kamaelia.Chassis.ConnectedServer.SimpleServer.html">SimpleServer</a>,
<a
href="/Components/pydoc/Kamaelia.Protocol.FortuneCookieProtocol.FortuneCookieProtocol.html">FortuneCookieProtocol</a>,
<a href="/Components/pydoc/Kamaelia.Chassis.Pipeline.html">Pipeline</a>,
<a
href="/Components/pydoc/Kamaelia.Internet.TCPClient.TCPClient.html">TCPClient</a>,
<a
href="/Components/pydoc/Kamaelia.Util.Console.ConsoleEchoer.html">ConsoleEchoer</a></p>
<p><span style="font-size:24pt;font-weight:600">Cookbook
Example</span></p>
<p><span style="font-size:18pt">How can I...?</span></p>
<p>Example 2: A Simple TCP Based Server that allows multiple connections
at once, but sends a random ogg vorbis file to the client. Includes a
simple TCP based client for this server, that connects to the server,
decodes the ogg vorbis audio and plays it back. <span
style="font-weight:600">Components used:</span><a
href="/Components/pydoc/Kamaelia.Util.PipelineComponent.pipeline.html">pipeline</a>,
<a
href="/Components/pydoc/Kamaelia.Chassis.ConnectedServer.SimpleServer.html">SimpleServer</a>,
<a
href="/Components/pydoc/Kamaelia.ReadFileAdaptor.ReadFileAdaptor.html">ReadFileAdaptor</a>,
<a
href="/Components/pydoc/Kamaelia.Internet.TCPClient.TCPClient.html">TCPClient</a>,
<a
href="/Components/pydoc/Kamaelia.vorbisDecodeComponent.VorbisDecode.html">VorbisDecode</a>,
<a
href="/Components/pydoc/Kamaelia.vorbisDecodeComponent.AOAudioPlaybackAdaptor.html">AOAudioPlaybackAdaptor</a></p>
<p><span style="font-size:24pt;font-weight:600">Cookbook
Example</span></p>
<p><span style="font-size:18pt">How can I...?</span></p>
<p>Example 3: Same as example 2, but as separate scripts. <span
style="font-weight:600">Components used in server script:</span> <a
href="/Components/pydoc/Kamaelia.Chassis.ConnectedServer.SimpleServer.html">SimpleServer</a>,
<a
href="/Components/pydoc/Kamaelia.ReadFileAdaptor.ReadFileAdaptor.html">ReadFileAdaptor</a>.
<span style="font-weight:600">Components used in client script:</span>
<a
href="/Components/pydoc/Kamaelia.Util.PipelineComponent.pipeline.html">pipeline</a>,
<a
href="/Components/pydoc/Kamaelia.Internet.TCPClient.TCPClient.html">TCPClient</a>,
<a
href="/Components/pydoc/Kamaelia.vorbisDecodeComponent.VorbisDecode.html">VorbisDecode</a>,
<a
href="/Components/pydoc/Kamaelia.vorbisDecodeComponent.AOAudioPlaybackAdaptor.html">AOAudioPlaybackAdaptor</a>
.</p>
<p>Server script</p>
<p>Client script</p>
<h3 id="build-multicast-based-clients-and-servers">Build Multicast Based
Clients and Servers</h3>
<p><span style="font-size:24pt;font-weight:600">Cookbook
Example</span></p>
<p><span style="font-size:18pt">How can I...?</span></p>
<p>Example 4: Building a very simplistic multicast based streaming
system using ogg vorbis. <span style="font-weight:600">Components
used:</span><span
style="font-style:italic;color:#ff0004">component</span>, <a
href="/Components/pydoc/Kamaelia.ReadFileAdaptor.ReadFileAdaptor.html">ReadFileAdaptor</a>,
<a
href="/Components/pydoc/Kamaelia.vorbisDecodeComponent.VorbisDecode.html">VorbisDecode</a>,
<a
href="/Components/pydoc/Kamaelia.vorbisDecodeComponent.AOAudioPlaybackAdaptor.html">AOAudioPlaybackAdaptor</a>,
<a
href="/Components/pydoc/Kamaelia.Internet.Multicast_transceiver.Multicast_transceiver.html">Multicast_transceiver</a>,
<a
href="/Components/pydoc/Kamaelia.Util.PipelineComponent.pipeline.html">pipeline</a></p>
<p><span style="font-size:24pt;font-weight:600">Cookbook
Example</span></p>
<p><span style="font-size:18pt">How can I...?</span></p>
<p>Example 4: Building a very simplistic multicast based streaming
system using ogg vorbis. This time using 2 separate scripts. <span
style="font-weight:600">Components used in server script:</span><span
style="font-style:italic;color:#ff0004">component</span>, <a
href="/Components/pydoc/Kamaelia.ReadFileAdaptor.ReadFileAdaptor.html">ReadFileAdaptor</a>,
<a
href="/Components/pydoc/Kamaelia.Internet.Multicast_transceiver.Multicast_transceiver.html">Multicast_transceiver</a>.
<span style="font-weight:600">Components used in client script:</span>
<span style="font-style:italic;color:#ff0004">component</span>, <a
href="/Components/pydoc/Kamaelia.Internet.Multicast_transceiver.Multicast_transceiver.html">Multicast_transceiver</a>,
<span style="font-style:italic;color:#ff0004">detuple</span> (defined in
the example), <a
href="/Components/pydoc/Kamaelia.vorbisDecodeComponent.VorbisDecode.html">VorbisDecode</a>,
<a
href="/Components/pydoc/Kamaelia.vorbisDecodeComponent.AOAudioPlaybackAdaptor.html">AOAudioPlaybackAdaptor</a>.</p>
<p>Server Script, the easy way</p>
<p>Server Script, the hard way (but exactly equivalent)</p>
<p>Client Script</p>
<p>Client Script, the hard way (but exactly equivalent)</p>
<p><span style="font-size:24pt;font-weight:600">Cookbook
Example</span></p>
<p><span style="font-size:18pt">How can I...?</span></p>
<p>Example 4: Building some reliability into the system (<a
href="/SimpleReliableMulticast.html">Simple Reliable Multicast</a>).
Idea is to show layering of protocols.<span
style="font-weight:600">Components used:</span><span
style="font-style:italic;color:#ff0004">component</span>, <a
href="/Components/pydoc/Kamaelia.ReadFileAdaptor.ReadFileAdaptor.html">ReadFileAdaptor</a>,
<a
href="/Components/pydoc/Kamaelia.vorbisDecodeComponent.VorbisDecode.html">VorbisDecode</a>,
<a
href="/Components/pydoc/Kamaelia.vorbisDecodeComponent.AOAudioPlaybackAdaptor.html">AOAudioPlaybackAdaptor</a>,
<a
href="/Components/pydoc/Kamaelia.Internet.Multicast_transceiver.Multicast_transceiver.html">Multicast_transceiver</a>,
<a
href="/Components/pydoc/Kamaelia.Util.PipelineComponent.pipeline.html">pipeline</a>,
<span style="font-style:italic;color:#ff0004">SRM_Sender</span>, <span
style="font-style:italic;color:#ff0004">SRM_Receiver</span></p>
<h3 id="create-udp-based-systems">Create UDP Based Systems<span
style="font-weight: 600;"></span></h3>
<ul>
<li><span style="font-weight: 600;"></span><a
href="/Examples/UDPSimplePeerExample.html">UDPSimplePeerExample</a><br />
</li>
</ul>
<h3 id="build-tools-for-system-visualisation-and-introspection">Build
tools for System Visualisation and Introspection</h3>
<ul>
<li><a
href="/Examples/IntrospectingASimpleStreamingSystem.html">IntrospectingASimpleStreamingSystem</a></li>
<li><a
href="/Examples/NetworkControllableGraphViewer.html">NetworkControllableGraphViewer</a></li>
<li><a
href="/Examples/BuildingACustomisedTopologyViewer.html">BuildingACustomisedTopologyViewer</a><br />
</li>
</ul>
<h3 id="build-multimedia-applications">Build Multimedia
Applications<span style="font-weight: 600;"></span></h3>
<ul>
<li><span style="font-weight: 600;"></span><a
href="/Examples/SimplestPresentationTool.html">SimplestPresentationTool</a></li>
<li><a
href="/Examples/TopologySlideshowComponent.html">TopologySlideshowComponent</a></li>
<li><a
href="/Examples/TopologyAndSlidesPresentationTool.html">TopologyAndSlidesPresentationTool</a></li>
<li><a
href="/Examples/SimpleTextTickerDemonstration.html">SimpleTextTickerDemonstration</a><br />
</li>
</ul>
<h3 id="working-with-open-gl">Working with Open GL</h3>
<p><em>Coming soon! (<a
href="http://svn.sourceforge.net/viewvc/kamaelia/trunk/Code/Python/Kamaelia/Examples/SoC2006/THF/">open
GL examples already in subversion here</a>)</em><br />
</p>
<h3 id="write-games">Write Games<span
style="font-weight: 600;"></span></h3>
<ul>
<li><span style="font-weight: 600;"></span><a
href="Examples/SimpleBouncingCatsGame.html">SimpleBouncingCatsGame</a></li>
</ul>
<h3 id="work-with-audio-and-video">Work with Audio and Video<span
style="font-weight: 600;"></span></h3>
<ul>
<li><a
href="/Examples/SimplestPossibleDiracVideoPlayer.html">SimplestPossibleDiracVideoPlayer</a></li>
<li><a
href="/Examples/DiracVideoEncodeAndDecodeChain.html">DiracVideoEncodeAndDecodeChain</a></li>
<li><a
href="/Examples/SimpleStreamerWithPlaylistCapability.html">SimpleStreamerWithPlaylistCapability</a></li>
<li><a
href="/Examples/SimpleClientForSavingContentsOfTCPStream.html">SimpleClientForSavingContentsOfTCPStream</a><span
style="font-weight: 600;"></span></li>
</ul>
<h3 id="working-with-http">Working with HTTP</h3>
<ul>
<li><a href="/Cookbook/HTTPServer.html">HTTPServer</a> - How can I
integrate a <strong>web server</strong> into my system? This is a
relatively low level component, but does form a base for doing lots of
interesting things.</li>
<li><a href="/Cookbook/HTTPClient.html">HTTPClient</a> - How can I
integrate a <strong>web client</strong> into my system? <strong>How can
I deal with RSS feeds?</strong><br />
</li>
</ul>
<h3 id="working-with-bittorrent">Working with BitTorrent</h3>
<ul>
<li><a
href="Cookbook/SimpleBitTorrentExample.html">SimpleBitTorrentExample</a></li>
</ul>
<h3 id="working-with-aim">Working with AIM</h3>
<ul>
<li><a href="Cookbook/AIM.html">Simple AIM client with Pygame</a></li>
</ul>
<h3 id="working-with-irc">Working with IRC</h3>
<ul>
<li><a href="/Cookbook/IRCClient.html">IRCClient</a></li>
</ul>
<h3 id="receiving-and-recording-dvb-broadcasts">Receiving and recording
DVB broadcasts</h3>
<ul>
<li><a
href="../../../Cookbook/DVB/TransportStreamCapture.html">TransportStreamCapture</a>
- how can I capture an entire transport stream? (a DVB multiplex puts
multiple channels inside a transport stream)<br />
</li>
<li><a
href="../../../Cookbook/DVB/TransportStreamDemuxer.html">TransportStreamDemuxer</a>
- how can I work with <strong>multiple channels</strong> from a
transport stream? (yes, you can deal with more than one at a time easily
:)<br />
</li>
<li><a
href="../../../Cookbook/DVB/SingleChannelTransportStreamCapture.html">SingleChannelTransportStreamCapture</a>
- How can I work with a <strong>single channel</strong> from a transport
stream?<br />
</li>
<li><a
href="../../../Cookbook/DVB/RecordNamedChannel.html">RecordNamedChannel</a>
- Numbers numbers numbers! I want to record BBC ONE! How can I use
<strong>named channels</strong> ?<br />
</li>
<li><a
href="../../../Cookbook/DVB/PersonalVideoRecorder.html">PersonalVideoRecorder</a>
- How can I record <strong>named programmes</strong> from a specific
channel? (without even specifying the time ? :-)<br />
</li>
</ul>
<hr />
<p>As an aside, I don't think the rounded boxes idea here was working
very well. In theory it was nice, but the actual resulting layout sucked
in practice. As a result I've reverted to something more traditional. If
anyone has a better idea, please change to that :-) -- Michael, 10 Feb
2007<br />
<br />
<br />
</p>
</div>

</div> <!-- end section -->
</div> <!-- end page container -->

<div class="banner">
<a href="https://www.bbc.co.uk/rd"><img src="/site-resources/BBCRD_Logo.jpg"></a>
<P id="mini">  Kamaelia is an open source project originated from and guided
by <a href="https://www.bbc.co.uk/rd">BBC Research.</a> For more information
browse the site or get in contact.
<br>This is an ongoing community based development site.  As a result the
contents of this page is the opinions of the contributors of the pages
involved not the organisations involved.  Specificially, this page may
contain personal views which are not the views of the BBC.

<br>(C) Copyright 2004-2024 Kamaelia Contributors, including the British
Broadcasting Corporation, All Rights Reserved.
</div>
</body>
</html>
