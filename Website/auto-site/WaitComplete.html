<html>
<head>
<title> index </title>
<link rel=stylesheet type="text/css" href="/site-resources/base.css">
<link rel=stylesheet type="text/css" href="/site-resources/pandoc.css">
</head>
<body>
<div class="banner">
<P> <a href="/Home.html">Home</a> | <a href="/About.html">About</a> | <a href="/Developers.html">Developers</a>
</div>
<div class="pagecontainer">
<div class="pagesection">
<div id="pagenote">
<p>Feb 2024 - This site, and Kamaelia are <a href="https://github.com/sparkslabs/kamaelia/issues/15">being updated</a>. There is significant work needed, and <a href="https://github.com/sparkslabs/kamaelia/pulls">PRs</a> are welcome.
</div>
<h1 id="axon.ipc.waitcomplete">Axon.Ipc.WaitComplete</h1>
<p>The purpose behind WaitComplete is to allow a generator based component to say cleanly: run this other generator for a while and when they're done, return to me. This allows for more direct representation of certain kinds of code structure. It is likely to be joined at somepoint with a "continue with this" style message. There are two common usecases where it is nice to use:<br />
</p>
<p>One is with regard to reading lines of data from a network connection. This allows for a more direct form of writing code, and essentially provides a mechanism of dealing with the idea that "you can't nest yield statements cleanly". But telling the scheduler "run this until it's finished, not me" you essentially gain that ability.</p>
<p>The other is where you are requesting a resource from a Kamaelia service using the idiom</p>
<p>Find the service, create links to talk to it</p>
<p>Send it a message</p>
<p>Wait for the response, containing the resource<br />
</p>
<p>Move on</p>
<ul>
<li>A good example of a resource that's like this is pygame displays<br />
</li>
</ul>
<h2 id="basic-usage">Basic Usage</h2>
<p>To give an example which isn't tied up with a usecase, but just shows the mechanism, you use it like this:<br />
</p>
<blockquote>
<pre><code>class myComponent(Axon.Component.component):
    def main(self):
        print &quot;Running inside main&quot;
        yield WaitComplete( self.someGenerator() )
        print &quot;Back Running inside main&quot;
        yield WaitComplete( self.anotherGenerator() )
        print &quot;Back Running inside main again&quot;

    def someGenerator(self):
        print &quot;running in the secondary generator&quot;
        yield 1
        print &quot;still running in the secondary generator&quot;
        yield 1

    def anotherGenerator(self):
        print &quot;running in the other secondary generator&quot;
        yield 1
        print &quot;still running in the other secondary generator&quot;
        yield 1</code></pre>
</blockquote>
<p>The way that runs it would result in the following output:<br />
</p>
<blockquote>
<pre><code>Running inside main
running in the secondary generator
still running in the secondary generator
Back Running inside main
running in the other secondary generator
still running in the other secondary generator
Back Running inside main again</code></pre>
</blockquote>
<p>This doesn't look like a big deal, but it's worth asking "what would this look like without WaitComplete" ?<br />
<br />
If we were doing this without WaitComplete, it would look like this:<br />
</p>
<pre><code>class myComponent(Axon.Component.component):
    def main(self):
        print &quot;Running inside main&quot;
        for i in self.someGenerator():
            yield i
        print &quot;Back Running inside main&quot;
        for i self.anotherGenerator():
            yield i
        print &quot;Back Running inside main again&quot;

    def someGenerator(self):
        print &quot;running in the secondary generator&quot;
        yield 1
        print &quot;still running in the secondary generator&quot;
        yield 1

    def anotherGenerator(self):
        print &quot;running in the other secondary generator&quot;
        yield 1
        print &quot;still running in the other secondary generator&quot;
        yield 1</code></pre>
<p>Whilst it's not that much worse, it does obfuscate things, as we'll see with real world examples.<br />
</p>
<h2 id="real-world-example---connecting-to-a-pop3-server-logging-in">Real world example - Connecting to a POP3 server &amp; Logging in</h2>
<p>The following code is from a basic POP3 client skeleton (as used in the client side spam tools):<br />
</p>
<blockquote>
<pre><code>    def waitForBanner(self):
        yield WaitComplete(self.getline(), tag=&quot;_getline1&quot;)
        self.banner = self.line.strip()

        if self.banner[:3] == &quot;+OK&quot;:
            self.connectionSuccess = True
        else:
            self.connectionSuccess = False

    def doLogin(self, username, password):
        self.sendCommand(&quot;USER &quot;+username)
        yield WaitComplete(self.getline(), tag=&quot;_getline2&quot;)
        if self.line[:3] == &quot;+OK&quot;:
            self.sendCommand(&quot;PASS &quot;+ password)
            yield WaitComplete(self.getline(), tag=&quot;_getline3&quot;)
            if self.line[:3] == &quot;+OK&quot;:
                self.loggedIn = True

    def main(self):
        self.control_message = None
        self.connectionSuccess = False
        self.loggedIn = False

        yield WaitComplete(self.waitForBanner())

        if self.connectionSuccess:
            yield WaitComplete( self.doLogin(self.username, self.password))

            if self.loggedIn:
                run = True
                while run:
                    while not self.anyReady():
                        self.pause()
                        yield 1
                    while self.dataReady(&quot;client_inbox&quot;):
                        command = self.recv(&quot;client_inbox&quot;)
                        yield WaitComplete(self.handleCommand(command))
                        if command[0] == &quot;QUIT&quot;:
                           run = False

                self.sendCommand(&quot;QUIT&quot;)
                yield WaitComplete(self.getline(), tag=&quot;_getline5&quot;)
#                print &quot;SERVER RESPONSE&quot;, self.line</code></pre>
</blockquote>
<p>Now, ignoring the tag= parts at the end, restructuring this to use the more tradition for ... in self.generator() syntax, you would get this:<br />
</p>
<blockquote>
<pre><code>    def waitForBanner(self):
        for i in self.getline():
            yield i

        self.banner = self.line.strip()

        if self.banner[:3] == &quot;+OK&quot;:
            self.connectionSuccess = True
        else:
            self.connectionSuccess = False

    def doLogin(self, username, password):
        self.sendCommand(&quot;USER &quot;+username)
        for i in self.getline():
            yield i
        if self.line[:3] == &quot;+OK&quot;:
            self.sendCommand(&quot;PASS &quot;+ password)
            for i in self.getline():
                yield i
            if self.line[:3] == &quot;+OK&quot;:
                self.loggedIn = True

    def main(self):
        self.control_message = None
        self.connectionSuccess = False
        self.loggedIn = False

        for i in self.waitForBanner():
            yield i

        if self.connectionSuccess:
            for i in self.doLogin(self.username, self.password):
                yield i

            if self.loggedIn:
                run = True
                while run:
                    while not self.anyReady():
                        self.pause()
                        yield 1
                    while self.dataReady(&quot;client_inbox&quot;):
                        command = self.recv(&quot;client_inbox&quot;)
                        for i in self.handleCommand(command):
                             yield i
                        if command[0] == &quot;QUIT&quot;:
                           run = False

                self.sendCommand(&quot;QUIT&quot;)
                for i in self.getline():
                    yield i
#                print &quot;SERVER RESPONSE&quot;, self.line</code></pre>
</blockquote>
<p>Whilst each individual part is only slightly less clear, the overall effect is significantly less clear.<br />
<br />
The tag= line incidentally allows us to give each call to a generator a different tag. This allows us to determine if a generator is getting stuck in any particular state. In the case of a network system, knowing just where the system is getting unexpected data (or not getting expected data) causing it to stay in an unexpected state is particularly useful - hence the use of tags. In the second, non-WaitComplete version we don't have that hinting available.<br />
</p>
<h2 id="real-world-example---requesting-a-pygame-display-surface">Real World Example - Requesting A Pygame Display Surface</h2>
<p>In this example we have to do this:<br />
</p>
<ul>
<li>Find the pygame display</li>
<li>Send it a request</li>
<li>Wait for the response</li>
</ul>
<p>This is a common task that would be nice to wrap up inside a method that we can just call trivially. Again this is where WaitComplete comes in, since it assists in wrapping up this functionality cleanly as follows:<br />
</p>
<blockquote>
<pre><code>    def __init__(self, **argd):
....
        self.disprequest = { &quot;DISPLAYREQUEST&quot; : True,
                           &quot;callback&quot; : (self,&quot;callback&quot;),
                           &quot;size&quot;: self.displaysize}

    def getDisplay(self):
       displayservice = PygameDisplay.getDisplayService()
       self.link((self,&quot;display_signal&quot;), displayservice)
       self.send(self.disprequest, &quot;display_signal&quot;)
       while not self.dataReady(&quot;callback&quot;):
           self.pause()
           yield 1
       self.display = self.recv(&quot;callback&quot;)</code></pre>
</blockquote>
<p>This can then be used like this:<br />
</p>
<blockquote>
<pre><code>    def main(self):
       yield WaitComplete(self.getDisplay())</code></pre>
</blockquote>
<p>And <strong>that</strong> is a significant simplication over the current structure.<br />
<br />
Furthermore, it also allows this:<br />
</p>
<blockquote>
<pre><code>    def getDisplay(self):

       def gen():
          displayservice = PygameDisplay.getDisplayService()
          self.link((self,&quot;display_signal&quot;), displayservice)
          self.send(self.disprequest, &quot;display_signal&quot;)

          while not self.dataReady(&quot;callback&quot;):
              self.pause()
              yield 1

          self.display = self.recv(&quot;callback&quot;)

       return WaitComplete(get())</code></pre>
</blockquote>
<p>Which can itself be used like this:<br />
</p>
<blockquote>
<pre><code>    def main(self):
       yield self.getDisplay()</code></pre>
</blockquote>
<p>It's perhaps worth noting that the common alternative here is this:<br />
</p>
<blockquote>
<pre><code>    def main(self):
       displayservice = PygameDisplay.getDisplayService()
       self.link((self,&quot;display_signal&quot;), displayservice)
       self.send(self.disprequest, &quot;display_signal&quot;)

       while not self.dataReady(&quot;callback&quot;):
           self.pause()
           yield 1

       self.display = self.recv(&quot;callback&quot;)</code></pre>
</blockquote>
<p>And that for example is something that can be placed into a potential baseclass to be used as a re-usable mixin, which can then just be used in a simple manner of "yield self.getDisplay()".<br />
Given that this is a commonly used idiom, the ability to cleanly wrap this is a massive advantage.<br />
</p>
<h2 id="summary">Summary</h2>
<p>WaitComplete is a useful as:<br />
</p>
<ul>
<li>Syntactic sugar to make a common construct clearer</li>
<li>A mechanism for wrapping up functionality that needs to yield inside a seperate method for reuse</li>
<li>A mechanism for assisting debugging of more complex systems, due to the tag= notation.</li>
</ul>
<p><br />
</p>

</div> <!-- end section -->
</div> <!-- end page container -->

<div class="banner">
<a href="https://www.bbc.co.uk/rd"><img src="/site-resources/BBCRD_Logo.jpg"></a>
<P id="mini">  Kamaelia is an open source project originated from and guided
by <a href="https://www.bbc.co.uk/rd">BBC Research.</a> For more information
browse the site or get in contact.
<br>This is an ongoing community based development site.  As a result the
contents of this page is the opinions of the contributors of the pages
involved not the organisations involved.  Specificially, this page may
contain personal views which are not the views of the BBC.

<br>(C) Copyright 2004-2024 Kamaelia Contributors, including the British
Broadcasting Corporation, All Rights Reserved.
</div>
</body>
</html>
