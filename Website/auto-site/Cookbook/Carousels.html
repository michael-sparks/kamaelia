<html>
<head>
<title> index </title>
<link rel=stylesheet type="text/css" href="/site-resources/base.css">
<link rel=stylesheet type="text/css" href="/site-resources/pandoc.css">
</head>
<body>
<div class="banner">
<P> <a href="/Home.html">Home</a> | 
    <a href="/About.html">About</a> | 
    <a href="/RecentChanges.html">Recent Changes</a> | 
    <a href="/Documentation.html">Documentation</a> |
    <a href="/Community.html">Community</a>
</div>
<div class="pagecontainer">
<div class="pagesection">
<div id="pagenote">
<p>March 2024 - This site, and Kamaelia are <a href="https://github.com/sparkslabs/kamaelia/issues/15">being updated</a>. There is significant work needed, and <a href="https://github.com/sparkslabs/kamaelia/pulls">PRs</a> are welcome.
</div>
<blockquote>
<p><br />
</p>
</blockquote>
<h1 id="cookbook-carousels">Cookbook : Carousels</h1>
<p>So you've built your components and wired them up using <a
href="/Cookbook/Pipelines%20">Pipelines</a> and <a
href="/Cookbook/Graphlines%20">Graphlines</a> . But what do you do if
you want to create or initialise a component at runtime?</p>
<p>Perhaps you can't know the value of some arguments until you start
reading that input file. Or maybe you want to process several streams of
data in sequence, but the component you want to use isn't designed to
process several streams back to back. This is where a component like the
<em>Carousel</em> comes in.</p>
<p>The Carousel gives us a way to create a component on-the-fly in
response to being sent a message.<br />
</p>
<h3 id="for-example...">For example...</h3>
<p>Suppose we want to play an MP3 file ... we could use a simple
pipeline like this:<br />
</p>
<blockquote>
<pre><code>from Kamaelia.File.Reading import RateControlledFileReader
from Kamaelia.Audio.Codec.PyMedia.Decoder import Decoder
from Kamaelia.Audio.PyMedia.Output import Output
from Kamaelia.Chassis.Pipeline import Pipeline

import sys
mp3filename=sys.argv[1]

Pipeline( RateControlledFileReader( mp3filename, readmode=&quot;bytes&quot;, rate=256000/8),
          Decoder(&quot;mp3&quot;),
          Output(sample_rate=44100, channels=2, format=&quot;S16_LE&quot;),
        ).run()</code></pre>
</blockquote>
<p><br />
That is all very nice; but what if we get the sample rate, number of
channels or format wrong? We can't get this information until we start
decoding it. If we get it wrong then the audio may be corrupted or
played at the wrong speed!<br />
<br />
It would be great if, at runtime, we could create the audio playback
(Output) component in response to receiving a message from the MP3
decoder containing the audio format:<br />
<br />
</p>
<div data-align="center">
<p><img src="/images/carousel1_idea.gif" /><br />
</p>
</div>
<p><br />
The PyMedia MP3 Decoder component we are using helpfully sends out a
message containing the information we need, so we can use the Carousel
component to do it like this:<br />
</p>
<blockquote>
<pre><code>from Kamaelia.Chassis.Graphline import Graphline
from Kamaelia.Chassis.Carousel import Carousel

def makeAudioOutput(metadata):
    return Output( metadata[&quot;sample_rate&quot;],
                   metadata[&quot;channels&quot;],
                   metadata[&quot;format&quot;]
                 )

Graphline( READ = RateControlledFileReader( mp3filename, readmode=&quot;bytes&quot;, rate=256000/8),
           DECODE = Decoder(&quot;mp3&quot;),
           OUTPUT = Carousel( makeAudioOutput ),
           linkages = {
               (&quot;READ&quot;,   &quot;outbox&quot;) : (&quot;DECODE&quot;, &quot;inbox&quot;),
               (&quot;DECODE&quot;, &quot;outbox&quot;) : (&quot;OUTPUT&quot;, &quot;inbox&quot;),
               (&quot;DECODE&quot;, &quot;format&quot;) : (&quot;OUTPUT&quot;, &quot;next&quot;),

               (&quot;READ&quot;,   &quot;signal&quot;) : (&quot;DECODE&quot;, &quot;control&quot;),
               (&quot;DECODE&quot;, &quot;signal&quot;) : (&quot;OUTPUT&quot;, &quot;control&quot;),
           }
         ).run()</code></pre>
</blockquote>
<p>This example is wired up using a Graphline component - find out more
about Graphlines <a href="/Cookbook/Graphlines%20">here</a> .<br />
</p>
<h3 id="so-what-does-this-do">So what does this do?</h3>
<h3 id="section"></h3>
<p>The MP3 Decoder component we are using helpfully sends out the format
of the decoded audio out of its "format" outbox, so we link this to the
Carousel's "next" inbox to control it. A message from the decoder wil
look like this:<br />
</p>
<blockquote>
<pre><code>{ &quot;sample_rate&quot; : 44100, &quot;channels&quot;:2, &quot;format&quot;:&quot;S16_LE&quot; }</code></pre>
</blockquote>
<p>We've also written a function makeAudioOutput(). When called with the
message as its argument; it returns a new Output component set up with
the right sample rate, number of channels, and format.</p>
<p>We give this function to the Carousel. Note that we don't call it -
we just give it the function. The Carousel calls it when it receives a
message on its "next" inbox and therefore needs to create the
component:</p>
<p><br />
</p>
<div data-align="center">
<p><img src="/images/carousel_anim.gif" /></p>
</div>
<p><br />
</p>
<ol type="1">
<li>The Carousel receives a message on its "next" inbox, containing the
format of the audio<br />
</li>
<li>The Carousel calls our <em>makeAudioOutput</em> function, passing it
this message as its parameter<br />
</li>
<li>Our function returns a new Output component, ready to be used.<br />
</li>
<li>Carousel links the new Output component up to use its own inboxes
and outboxes</li>
</ol>
<p>So when the raw audio samples start to arrive at its inbox, there
will be a new Output component already linked in to receive them.<br />
Note that it does not link the "signal" outbox - this is so that when
the component finishes and sends its own shutdown message, this doesn't
get passed on - after all, you might want to reuse the Carousel with
another component.<br />
</p>
<h3 id="so-why-is-it-called-a-carousel-then">So why is it called a
"Carousel" then?</h3>
<h3 id="section-1"></h3>
<p>If you send another message to the "next" inbox, then the component
gets replaced. Any existing component is told to shutdown and is thrown
away as soon as possible, and a new one is created, by calling our
function with the new message as the parameter.<br />
<br />
This kind of behaviour is a little like the carousel on an old slide
projector - when you want to move on, the old item is swapped for the
next one. Alternatively think of a fairground merry-go-round carousel -
where one horse comes by after another.<br />
<br />
For example, suppose we want to improve our MP3 player by making it play
multiple files back to back. We could put everything in a Carousel, then
when it has finished, it could send us a message. We could then respond
by sending it the next filename to play, and letting it start again.
Something like this:<br />
</p>
<div data-align="center">
<p><img src="/images/carousel_anim2.gif" /><br />
</p>
<div data-align="left">
<p>We can do this by using a Chooser component for the playlist and
putting our existing player inside a Carousel. When all the player
components finish, our Carousel will send out a "next" message from its
"requestNext" outbox, which we can use to cause our Chooser to send back
the next filename:</p>
<p><img src="/images/carousel3.gif" /></p>
<p>Notice that we can also wire up the "signal" and "control" boxes, so
that when the Chooser has no more names in its playlist, it can tell our
player Carousel to shut down.<br />
</p>
<p>So now lets build this! First, lets make a function that we will give
to the Carousel for it to use to create our player:<br />
</p>
<blockquote>
<pre><code>def makePlayer(mp3filename):
    return Graphline(
        READ = RateControlledFileReader( mp3filename, readmode=&quot;bytes&quot;, rate=256000/8),
        DECODE = Decoder(&quot;mp3&quot;),
        OUTPUT = Carousel( makeAudioOutput ),
        linkages = {
            (&quot;READ&quot;,   &quot;outbox&quot;) : (&quot;DECODE&quot;, &quot;inbox&quot;),
            (&quot;DECODE&quot;, &quot;outbox&quot;) : (&quot;OUTPUT&quot;, &quot;inbox&quot;),
            (&quot;DECODE&quot;, &quot;format&quot;) : (&quot;OUTPUT&quot;, &quot;next&quot;),

            (&quot;&quot;,      &quot;control&quot;) : (&quot;READ&quot;,   &quot;control&quot;),
            (&quot;READ&quot;,   &quot;signal&quot;) : (&quot;DECODE&quot;, &quot;control&quot;),
            (&quot;DECODE&quot;, &quot;signal&quot;) : (&quot;OUTPUT&quot;, &quot;control&quot;),
            (&quot;OUTPUT&quot;, &quot;signal&quot;) : (&quot;&quot;,       &quot;signal&quot;),
        }
      )</code></pre>
</blockquote>
</div>
</div>
<p>This is almost identical to our player from before. Notice we've
added extra links to make sure shutdown messages can get into and out of
the Graphline. This is important, as Carousel will be listening for our
Graphline sending the shutdown message.<br />
<br />
Now lets wire it all up! We will use a <em>ForwardIteratingChooser</em>
because it will send a shutdown message once all the filenames have been
iterated over:<br />
</p>
<blockquote>
<pre><code>from Kamaelia.Util.Chooser import ForwardIteratingChooser

filenames = argv[1:]

Graphline( PLAYLIST = ForwardIteratingChooser(filenames),
           PLAYER   = Carousel( makePlayer, make1stRequest=True ),
           linkages = {
               (&quot;PLAYER&quot;,   &quot;requestNext&quot;) : (&quot;PLAYLIST&quot;, &quot;inbox&quot;),
               (&quot;PLAYLIST&quot;, &quot;outbox&quot;)      : (&quot;PLAYER&quot;,   &quot;next&quot;),

               (&quot;PLAYLIST&quot;, &quot;signal&quot;) : (&quot;PLAYER&quot;, &quot;control&quot;),
           }
         ).run()</code></pre>
</blockquote>
<p>Notice that we have asked the Carousel to make the 1st request. What
this means is that as soon as it starts it will send out its request for
the next item - instead of just waiting. This gets things going.<br />
<br />
So there we have it, a simple mp3 playlist system, built entirely in
Kamaelia, using Carousels to create components with the right settings
when we need them.<br />
</p>
<p>-- 19 Dec 2006 - Matt Hammond<br />
</p>

</div> <!-- end section -->
</div> <!-- end page container -->

<div class="banner">
<a href="https://www.bbc.co.uk/rd"><img src="/site-resources/BBCRD_Logo.jpg"></a>
<P id="mini">  Kamaelia is an open source project originated from and guided
by <a href="https://www.bbc.co.uk/rd">BBC Research.</a> For more information
browse the site or get in contact.
<br>This is an ongoing community based development site.  As a result the
contents of this page is the opinions of the contributors of the pages
involved not the organisations involved.  Specificially, this page may
contain personal views which are not the views of the BBC.

<br>(C) Copyright 2004-2024 Kamaelia Contributors, including the British
Broadcasting Corporation, All Rights Reserved.
</div>
</body>
</html>
