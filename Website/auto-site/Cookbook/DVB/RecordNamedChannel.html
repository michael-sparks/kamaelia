<html>
<head>
<title> index </title>
<link rel=stylesheet type="text/css" href="/site-resources/base.css">
<link rel=stylesheet type="text/css" href="/site-resources/pandoc.css">
</head>
<body>
<div class="banner">
<P> <a href="/Home.html">Home</a> | 
    <a href="/About.html">About</a> | 
    <a href="/RecentChanges.html">Recent Changes</a> | 
    <a href="/Documentation.html">Documentation</a> |
    <a href="/Community.html">Community</a>
</div>
<div class="pagecontainer">
<div class="pagesection">
<div id="pagenote">
<p>Feb 2024 - This site, and Kamaelia are <a href="https://github.com/sparkslabs/kamaelia/issues/15">being updated</a>. There is significant work needed, and <a href="https://github.com/sparkslabs/kamaelia/pulls">PRs</a> are welcome.
</div>
<h1 id="cookbook-recording-a-named-channel-from-a-dvb-broadcast">Cookbook : Recording a named channel from a DVB broadcast</h1>
<p><em>Find the code for this here:<br />
</em><a href="http://svn.sourceforge.net/viewvc/kamaelia/trunk/Code/Python/Kamaelia/Examples/DVB_Systems/RecordNamedChannel.py?view=markup">/Code/Python/Kamaelia/Examples/DVB_Systems/RecordNamedChannel.py</a></p>
<p>Recording a channel from a DVB (digital video broadcasting) broadcast <a href="../../../Cookbook/DVB/SingleChannelTransportStreamCapture">is relatively simple</a><a href="../../../Cookbook/DVB/SingleChannelTransportStreamCapture"></a> if you know the packet IDs (PIDs) for packets containing the audio and video streams of the service (the channel) you want to record. But what if you only know the channel's name?</p>
<p>In this example the component <em>DVB_TuneToChannel</em> uses various DVB components to extract and parse the Program Specific Information (PSI) tables needed to work it out itself. It therefore needs to be able to talk to the DVB <em>Receiver</em> to request packets with varous PIDs as it realises it needs them.</p>
<p>The top level of the system is therefore this:</p>
<pre><code>    from Kamaelia.Chassis.Graphline import Graphline
    from Kamaelia.File.Writing import SimpleFileWriter
    
    import dvb3.frontend

    feparams = {
        &quot;inversion&quot; : dvb3.frontend.INVERSION_AUTO,
        &quot;constellation&quot; : dvb3.frontend.QAM_16,
        &quot;coderate_HP&quot; : dvb3.frontend.FEC_3_4,
        &quot;coderate_LP&quot; : dvb3.frontend.FEC_3_4,
    }

    from Kamaelia.Device.DVB.Receiver import Receiver
    
    RegisterService( Receiver(505833330.0/1000000.0, feparams),
                     {&quot;MUX1&quot;:&quot;inbox&quot;}
                   ).activate()
        
    Pipeline( DVB_TuneToChannel(channel=&quot;BBC ONE&quot;,fromDemuxer=&quot;MUX1&quot;),
              SimpleFileWriter(&quot;bbc_one.ts&quot;),
            ).run()</code></pre>
<p>The DVB <em>Receiver</em> component (which contains both a tuner and demuxer) is registered as a named service "MUX1". <em>DVB_TuneToChannel</em> is given its name, so it can request packets with specific PIDs.<br />
<br />
<em>DVB_TuneToChannel</em> is then pipelined with a <em>SimpleFileWriter</em> so that audio and video packets it eventually outputs will be written to a file.<br />
</p>
<h2 id="what-does-dvb_tunetochannel-do">What does DVB_TuneToChannel do?</h2>
<p>The component takes a channel name, and the name of the demuxer service as arguments:</p>
<blockquote>
<pre><code>class DVB_TuneToChannel(AdaptiveCommsComponent):
    ...

    def __init__(self, channel, fromDemuxer):
        super(DVB_TuneToChannel,self).__init__()
        self.channelname = channel
        self.demuxerservice = fromDemuxer</code></pre>
</blockquote>
<p>First, <em>DVB_TuneToChannel</em> resolves the demuxer service name it was given and adds an outbox and linkage to allow it to send requests to it:</p>
<pre><code>    def main(self):
        # get the demuxer service
        toDemuxer = self.addOutbox(&quot;toDemuxer&quot;)
        cat = CAT.getcat()
        service = cat.retrieveService(self.demuxerservice)
        self.link((self,toDemuxer),service)</code></pre>
<p>Before they can be parsed, PSI tables need to be reconstructed from the transport stream packets they are carried in. So next it sets up a named service "PSI" to reconstruct them, based on a <em>ReassemblePSITablesService</em> component. It is linked to the demuxer service so it can requests packets with the PIDs it needs:</p>
<pre><code>        psi = ReassemblePSITablesService()
        psi_service = RegisterService(psi,{&quot;PSI&quot;:&quot;request&quot;}).activate()
        self.link( (psi,&quot;pid_request&quot;), service )</code></pre>
<h3 id="resolving-service-name-to-service-id">1. Resolving service name to service id</h3>
<p>The first step is to resolve the service name "BBC ONE" in this example, to the service's id. This data is held in the Service Description Table (SDT), which is carried in a fixed PID. So <em>DVB_TuneToChannel</em> creates the correct parsing component and subscribes it to the PSI table service; then adds an inbox and links it to receive output from the pipeline:</p>
<pre><code>        sdt_parser = Pipeline( Subscribe(&quot;PSI&quot;, [SDT_PID]),
                               ParseServiceDescriptionTable_ActualTS()
                             ).activate()
        
        fromSDT = self.addInbox(&quot;fromSDT&quot;)
        fromSDT_linkage = self.link( (sdt_parser,&quot;outbox&quot;),(self,fromSDT) )</code></pre>
<p><em>DVB_TuneToChannel</em> then waits for the parsing component to return a table and searches it for the matching service ID and transport stream ID:<br />
</p>
<pre><code>        service_id = None
        while service_id == None:
            while not self.dataReady(fromSDT):
                self.pause()
                yield 1
        
            sdt_table = self.recv(fromSDT)
            
            transport_stream_id = sdt_table[&#39;transport_stream_id&#39;]
            
            # see if we can find our services channel name
            for (sid,service) in sdt_table[&#39;services&#39;].items():
                for (dtype,descriptor) in service[&#39;descriptors&#39;]:
                    if descriptor[&#39;type&#39;] == &quot;service&quot;:
                        if descriptor[&#39;service_name&#39;].lower() == self.channelname.lower():
                            service_id = sid
                            break
        
        print &quot;Found service id:&quot;,service_id
        print &quot;Its in transport stream id:&quot;,transport_stream_id</code></pre>
<p>The PIDs for the audio and video streams are recorded in a Program Map Table (PMT). There is one of these for each service in the multiplex. The PIDs for these are listed in the Program Association Table (PAT) which is carried in packets with a known PID.<br />
</p>
<p>So the next steps are to examine the Program Association Table, then find and examine the correct Program Map Table for the service we want.</p>
<h3 id="finding-the-program-map-table-for-a-given-service-id">2. Finding the Program Map Table for a given service id</h3>
<p>As was done for the Service Description table, <em>DVB_TuneToChannel</em> sets up a parser for the Program Association Table, and an inbox to collect the results:</p>
<pre><code>        pat_parser = Pipeline( Subscribe(&quot;PSI&quot;, [PAT_PID]),
                               ParseProgramAssociationTable()
                             ).activate()
        
        fromPAT = self.addInbox(&quot;fromPAT&quot;)
        fromPAT_linkage = self.link( (pat_parser,&quot;outbox&quot;),(self,fromPAT) )</code></pre>
<p>It then waits for a parsed table to be returned and searches it for the PID for packets containing the Program Map Table for the service:<br />
</p>
<pre><code>        # wait until we get data back from the PAT
        PMT_PID = None
        while PMT_PID == None:
            while not self.dataReady(fromPAT):
                self.pause()
                yield 1
        
            sdt_table = self.recv(fromPAT)
            # see if we can find our service&#39;s PMT
            ts_services = sdt_table[&#39;transport_streams&#39;][transport_stream_id]
            if service_id in ts_services:
                PMT_PID = ts_services[service_id]
                break
            
        print &quot;Found PMT PID for this service:&quot;,PMT_PID</code></pre>
<h3 id="finding-the-pids-containing-audio-and-video">3. Finding the PIDs containing audio and video</h3>
<p>Nowthe PID for packets containing the Program Map Table is known, <em>DVB_TuneToChannel</em> can set up a parser that table:<br />
</p>
<pre><code>        pmt_parser = Pipeline( Subscribe(&quot;PSI&quot;, [PMT_PID]),
                               ParseProgramMapTable()
                             ).activate()
        
        fromPMT = self.addInbox(&quot;fromPMT&quot;)
        fromPMT_linkage = self.link( (pmt_parser,&quot;outbox&quot;),(self,fromPMT) )</code></pre>
<p>It then waits for the parsed table to be returned and searches for the first PIDs it can find for an audio and a video stream:</p>
<pre><code>        # wait until we get data back from the PMT
        audio_pid = None
        video_pid = None
        while audio_pid == None and video_pid == None:
            while not self.dataReady(fromPMT):
                self.pause()
                yield 1

        pmt_table = self.recv(fromPMT)
            if service_id in pmt_table[&#39;services&#39;]:
                service = pmt_table[&#39;services&#39;][service_id]
                for stream in service[&#39;streams&#39;]:
                    if   stream[&#39;type&#39;] in [3,4] and not audio_pid:
                        audio_pid = stream[&#39;pid&#39;]
                    elif stream[&#39;type&#39;] in [1,2] and not video_pid:
                        video_pid = stream[&#39;pid&#39;]

        print &quot;Found audio PID:&quot;,audio_pid
        print &quot;Found video PID:&quot;,video_pid</code></pre>
<h3 id="demuxing-the-audio-and-video-packets">4. Demuxing the audio and video packets</h3>
<p>Now the PIDs for packets containing the service's audio and video are known, the final step is for <em>DVB_TuneToChannel</em> to request to be sent packets with those PIDs; so they can be sent on out of its "outbox" outbox (to go to the file writer component):</p>
<pre><code>        fromDemuxer = self.addInbox(&quot;fromDemuxer&quot;)
        self.send( (&quot;ADD&quot;,[audio_pid,video_pid], (self,fromDemuxer)), toDemuxer)
        
        while 1:
            while self.dataReady(fromDemuxer):
                packet = self.recv(fromDemuxer)
                self.send(packet,&quot;outbox&quot;)
                
            self.pause()
            yield 1</code></pre>
<p>So there you have it. <em>DVB_TuneToChannel</em> uses various parsing components that are part of Kamaelia to extract and interpret the Program Specific Information tables available in a DVB multiplex carrying an MPEG transport stream.<br />
</p>
<p>-- 04 Jan 2007, Matt<br />
</p>

</div> <!-- end section -->
</div> <!-- end page container -->

<div class="banner">
<a href="https://www.bbc.co.uk/rd"><img src="/site-resources/BBCRD_Logo.jpg"></a>
<P id="mini">  Kamaelia is an open source project originated from and guided
by <a href="https://www.bbc.co.uk/rd">BBC Research.</a> For more information
browse the site or get in contact.
<br>This is an ongoing community based development site.  As a result the
contents of this page is the opinions of the contributors of the pages
involved not the organisations involved.  Specificially, this page may
contain personal views which are not the views of the BBC.

<br>(C) Copyright 2004-2024 Kamaelia Contributors, including the British
Broadcasting Corporation, All Rights Reserved.
</div>
</body>
</html>
