<html>
<head>
<title> index </title>
<link rel=stylesheet type="text/css" href="/site-resources/base.css">
<link rel=stylesheet type="text/css" href="/site-resources/pandoc.css">
</head>
<body>
<div class="banner">
<P> <a href="/Home.html">Home</a> | <a href="/About.html">About</a> | <a href="/Developers.html">Developers</a>
</div>
<div class="pagecontainer">
<div class="pagesection">
<div id="pagenote">
<p>Feb 2024 - This site, and Kamaelia are <a href="https://github.com/sparkslabs/kamaelia/issues/15">being updated</a>. There is significant work needed, and <a href="https://github.com/sparkslabs/kamaelia/pulls">PRs</a> are welcome.
</div>
<h1 id="cookbook-creating-tcp-systems">Cookbook: Creating TCP Systems</h1>
<div class="boxright">
<p>There are a number of lower down cookbook recipes for TCP systems in Kamaelia. This cookbook page walks through a small number of techniques which are useful in creating TCPSystems.<br />
<strong>Discussion</strong> Please discuss this on <a href="http://backend.kamaelia.org/Cookbook/TCPSystemsDiscuss">the discussion page</a> for this page</p>
</div>
<p>One of the earliest systems that Kamaelia was designed for was to build network systems, specifically scaleable TCP based network servers.<br />
</p>
<h2 id="an-echo-server"><strong>An Echo Server</strong></h2>
<p>One of the more trivial examples of TCP server is the traditional echo server. On the surface of things echo servers tend to look useless, but are often extremely useful for simply testing the question "is this thing on?". As a result that's why even Skype has something similar! An echo server takes whatever message it recieves and sends it back to you.<br />
<br />
In Kamaelia building this protocol is relatively easy to do:<br />
</p>
<blockquote>
<div data-align="left">
<pre><code>import Axon
from Kamaelia.Chassis.ConnectedServer import SimpleServer

class Echo(Axon.Component.component):
    def main(self):
        while 1:
            while self.dataReady(&quot;inbox&quot;):
                data = self.recv(&quot;inbox&quot;)
                self.send(data, &quot;outbox&quot;)
            yield 1

SimpleServer(protocol=Echo, port=1500).run()</code></pre>
</div>
<p><strong>Example 1:</strong> Basic echo server<br />
</p>
</blockquote>
<p>We can then run this and connect back to our server: (locally typed chars in italics)<br />
</p>
<blockquote>
<pre><code># telnet 127.0.0.1 1500
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is &#39;^]&#39;.
Hello
Hello
This
This
is
is
a
a
test
test</code></pre>
</blockquote>
<p>As you can see this works pretty much you'd hope - you provide something that can create protocol handlers to the simple server. When a connection occurs, the simple server creates an instance, and that instance recieves data from the socket on its inbox "inbox", and any data it sends to its outbox "outbox" is sent to the socket.<br />
</p>
<h2 id="shutting-down-the-connection-inside-the-protocol-handler"><strong>Shutting Down the Connection inside the Protocol Handler</strong></h2>
<p>OK, so that's a trivial server, how about something a little more complex? How about a protocol that when a client connects it runs, sends a message to the user and then breaks the connection? This is very similar to a "message of the day service" or a finger service.<br />
<br />
Well, to do this, we don't actually care about looping or waiting for data, or anything similar and interesting, we can just send messages and shutdown. Specifically to shutdown, we send a Axon.Ipc.shutdownMicroprocess message out of our "signal" outbox, so a simple "message of the day" server could look like this:<br />
</p>
<blockquote>
<div data-align="left">
<pre><code>import Axon
from Kamaelia.Chassis.ConnectedServer import SimpleServer

message = &quot;&quot;&quot;\
Hello, this is the message of the day

Bye Bye!
&quot;&quot;&quot;

class MOTD(Axon.Component.component):
    def main(self):
        self.send(message, &quot;outbox&quot;)
        self.send(Axon.Ipc.shutdownMicroprocess(), &quot;signal&quot;)
        print &quot;Shutting down&quot;
        yield 1

SimpleServer(protocol=MOTD, port=1501).run()</code></pre>
<p><strong>Example 2:</strong> Basic server with a message of the day protocol that shuts down immediately<br />
</p>
</div>
</blockquote>
<h2 id="handling-a-shutdown-message-from-the-socket"><strong>Handling a shutdown message from the socket</strong></h2>
<p>When a client breaks their connection, the protocol handler recieves a <em>Kamaelia.IPC.socketShutdown</em> IPC mesage on it's control inbox, which you can test for in order to determine whether to shutdown or not! Taking the original echo protocol above and extending it to handle this, looks like this:<br />
</p>
<div data-align="left">
<blockquote>
<pre><code>import Axon
import Kamaelia.IPC 
from Kamaelia.Chassis.ConnectedServer import SimpleServer

class Echo(Axon.Component.component):
    def main(self):
        protocolRunning = True
        while protocolRunning:
            while self.dataReady(&quot;inbox&quot;):
                data = self.recv(&quot;inbox&quot;)
                self.send(data, &quot;outbox&quot;)
            while self.dataReady(&quot;control&quot;):
                data = self.recv(&quot;control&quot;)
                if isinstance(data, Kamaelia.IPC.socketShutdown):
                    protocolRunning = False
            yield 1
        print &quot;Protocol finished!&quot;

SimpleServer(protocol=Echo, port=1500).run()</code></pre>
<p><strong>Example 3:</strong> Server with a protocol that shuts down when it recieves notification the socket has shutdown<br />
</p>
</blockquote>
</div>
<p>OK, so that's a relatively simple component - what about a simple component that sits, waits for a message, and when it gets one, sends one message in response and also shuts down? Well, this is kinda a combination of examples 1&amp; 2. In realworld terms, this is very similar conceptually to the "finger" protocol (though not quite :), and has basic similarities to HTTP as well.<br />
</p>
<blockquote>
<div data-align="left">
<pre><code>import Axon
import Kamaelia.IPC 
from Kamaelia.Chassis.ConnectedServer import SimpleServer

class Echo(Axon.Component.component):
    def main(self):
        while not self.dataReady():
            yield 1

        message = self.recv(&quot;inbox&quot;)
        self.send(&quot;You sent the message:&quot; + message, &quot;outbox&quot;)
        self.send(Axon.Ipc.shutdownMicroprocess(), &quot;signal&quot;)
        print &quot;Protocol finished!&quot;
        yield 1

SimpleServer(protocol=Echo, port=1500).run()</code></pre>
<p><strong>Example 4:</strong> Server with a protocol that sends a message and shuts down when it recieves any message from the connection<br />
</p>
</div>
</blockquote>
<p>There's a couple of further examples worth looking at here. One is a protocol that runs and when it recieves a special message - in this case the word "shutdown" - it causes the connection to be shutdown, but also one that also handles a client disconnection:<br />
</p>
<blockquote>
<div data-align="left">
<pre><code>import Axon
import Kamaelia.IPC 
from Kamaelia.Chassis.ConnectedServer import SimpleServer

class Echo(Axon.Component.component):
    def main(self):
        protocolRunning = True
        while protocolRunning:
            while self.dataReady(&quot;inbox&quot;):
                data = self.recv(&quot;inbox&quot;)
                if &quot;shutdown&quot; in data:
                    protocolRunning = False
                    self.send(Axon.Ipc.shutdownMicroprocess(), &quot;signal&quot;)
                else:
                    self.send(&quot;munch&quot;+data, &quot;outbox&quot;)

            while self.dataReady(&quot;control&quot;):
                data = self.recv(&quot;control&quot;)
                if isinstance(data, Kamaelia.IPC.socketShutdown):
                    protocolRunning = False
            yield 1
        print &quot;Protocol finished!&quot;

SimpleServer(protocol=Echo, port=1500).run()</code></pre>
</div>
<p><strong>Example 5:</strong> Server with a protocol where the client can forcibly break the connection or request disconnection<br />
</p>
</blockquote>
<p>A final basic example is how to create a server that when a client connects the server will send a message and shutdown. For this the client needs to send a serverShutdown message to a serversignal outbox as well as a shutdownMicroprocess to the signal.<br />
</p>
<div data-align="left">
<blockquote>
<pre><code>import Axon
from Kamaelia.Chassis.ConnectedServer import SimpleServer
from Kamaelia.IPC import serverShutdown

message = &quot;&quot;&quot;Hello, this is the message of the day
Bye Bye!&quot;&quot;&quot;

class MOTD(Axon.Component.component):
    Outboxes = [&quot;outbox&quot;, &quot;signal&quot;, &quot;serversignal&quot;]
    def main(self):
        self.send(message, &quot;outbox&quot;)
        self.send(serverShutdown(), &quot;serversignal&quot;)
        print &quot;Shutting down&quot;
        yield 1

SimpleServer(protocol=MOTD, port=1501).run()</code></pre>
<p><strong>Example 6:</strong> Server where the server shuts down as soon as the first client connects.<br />
</p>
</blockquote>
</div>
<h2 id="shared-markov-chain-protocol">Shared Markov Chain Protocol</h2>
<p>For a more fun example, let's create a simple server that accepts connections from users, and is expected to chat to the people who connect. For extra bonus points, what it will do is take anything that's typed to it, and use this to build up a simple markov chain. This markov chain will be shared between all connections, and as a result its dialogue will grow as the number of connections to it grows.<br />
<br />
Whilst this sounds complex, the code is relatively simple, and focusses almost entirely around the markov chain aspects rather than the network system aspects.<br />
<br />
I wrote this as an example of a relatively simple, but non-trivial network protocol. It creates a server that sits there waiting for connections. Anything that you type at it updates the markov chain for anyone/everyone connected. The protocol handler itself could be bolted into an IRC bot instead so you could have a deranged bot sitting on a channel which talks vaguely on-topic (but relatively - not totally - incoherently) most of the time. I thought I'd blog about it because it makes quite a nice fun/simple introduction to Kamaelia in it's own special way. The markov chain used is based on the one here. (courtesy of a google search)<br />
</p>
<div data-align="left">
<blockquote>
<pre><code>import Axon, random
nlnl = &#39;\n&#39;, &#39;\n&#39;
key = nlnl

def new_key(key, word):
   if word == &#39;\n&#39;: return nlnl
   else: return (key[1], word)

class Chatty(Axon.Component.component):
   data = {}
   def updateChain(self, message):
       key = nlnl
       for word in message.split():
           self.__class__.data.setdefault(key, []).append(word)
           key = new_key(key, word)

   def response(self):
       key, result, word = nlnl, [], None
       while word != &quot;\n&quot;:
           word = random.choice(self.__class__.data.get(key, nlnl))
           key = new_key(key, word)
           result.append(word)
       return &quot; &quot;.join(result)

   def main(self):
       while 1:
           if self.dataReady(&quot;inbox&quot;):
               message = self.recv(&quot;inbox&quot;)
               self.updateChain(message)
               self.send(self.response(), &quot;outbox&quot;)
           yield 1

if __name__ == &quot;__main__&quot;:
    from Kamaelia.Chassis.ConnectedServer import SimpleServer
    SimpleServer(protocol=Chatty, port=1500).run()</code></pre>
<p><strong>Example 7:</strong> Markov Chain Chat server.<br />
</p>
</blockquote>
</div>
<p><br />
And that's pretty much all there is to it. As you'd imagine (I hope), a Chatty component is created to handle any accepted connection on port 1500, and anything the user types is received on the inbox "inbox", used to update the class's markov chain DB, and then generates a response to send to the outbox "outbox" (meaning it gets sent to the socket). The upshot is the more people who connect, the more the database gets updated.<br />
<br />
The nice thing about this is that the bulk of the code here focusses on the logic that's desired, not on any networking details. OK, this example isn't ideal because it misses some important things like shutdown and what happens if the connection disappears, but it also is interesting because you can test the component in isolation as well:<br />
</p>
<blockquote>
<pre><code>Pipeline(
        ConsoleReader(),
        Chatty(),
        ConsoleEchoer(),
).run()</code></pre>
</blockquote>
<p>Which is a nice thing to be able to do! If you wanted to train the markov chain server you could also do that as follows:<br />
</p>
<blockquote>
<pre><code>Pipeline(
        ReadFileAdaptor(&quot;SomeTrainingMaterial&quot;),
        TCPClient(&quot;127.0.0.1&quot;, 1500), # assuming localhost
        ConsoleEchoer(), # May as well see the deranged output :)
).run()</code></pre>
</blockquote>
<p>The fun thing about this trainer is that you can see the output from the markov chain during testing as well :-)<br />
<br />
-- Michael, January 2007<br />
</p>

</div> <!-- end section -->
</div> <!-- end page container -->

<div class="banner">
<a href="https://www.bbc.co.uk/rd"><img src="/site-resources/BBCRD_Logo.jpg"></a>
<P id="mini">  Kamaelia is an open source project originated from and guided
by <a href="https://www.bbc.co.uk/rd">BBC Research.</a> For more information
browse the site or get in contact.
<br>This is an ongoing community based development site.  As a result the
contents of this page is the opinions of the contributors of the pages
involved not the organisations involved.  Specificially, this page may
contain personal views which are not the views of the BBC.

<br>(C) Copyright 2004-2024 Kamaelia Contributors, including the British
Broadcasting Corporation, All Rights Reserved.
</div>
</body>
</html>
